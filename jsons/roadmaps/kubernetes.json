{
  "content": {
    "adding-and-managing-worker-nodes@2cQKTxln3dIk5IjX2UZdM": "# Managing Worker Nodes\n\nKubernetes runs your workload by placing containers into Pods to run on Nodes. A node may be a virtual or physical machine, depending on the cluster. Each node is managed by the control plane and contains the services necessary to run Pods.\n\nVisit the following resources to learn more:\n\n- [@official@Node Management](https://kubernetes.io/docs/concepts/architecture/nodes/#management)\n- [@video@Kubernetes 101: Nodes Tutorial](https://www.youtube.com/watch?v=xhwi3zIVR-8)",
    "advanced-topics@t8SJbGVXsUDECxePLDk_w": "# Advanced Kubernetes Topics\n\nAdvanced Kubernetes concepts cover production-grade techniques for DevOps, Docker, and backend development. These include GitOps deployments, container optimization, stateful workloads management, secure cloud-native applications and service scalable implementations.\n\nVisit the following resources to learn more:\n\n- [@official@Kubernetes Production Best Practices](https://kubernetes.io/docs/setup/production-environment/)\n- [@article@Top Kubernetes design patterns](https://www.wallarm.com/what/top-kubernetes-design-patterns)\n- [@article@The Role of Kubernetes in DevOps](https://spacelift.io/blog/kubernetes-devops)\n- [@video@Kubernetes for Docker Users](https://www.youtube.com/watch?v=keNQ6V_W4VE&ab_channel=Rancher)",
    "assigning-quotas-to-namespaces@OHz4QMmA3lqL_C7aWL8Ga": "# Assigning Quotas to Namespaces\n\nAssigning quotas to namespaces is a way to limit resource usage for specific groups of resources in Kubernetes. Quotas can be set for CPU, memory, and other resources, as well as for the number of objects in a namespace. This can help ensure fair resource distribution across different teams or projects within a cluster. Quotas can be applied to individual namespaces or across the entire cluster. Kubernetes allows for both hard quotas, which enforce strict resource limits, and soft quotas, which allow for overages up to a certain point. Quotas can be managed using the Kubernetes API or through YAML configuration files.\n\nVisit the following resources to learn more:\n\n- [@official@Resource Quotas - Documentation](https://kubernetes.io/docs/concepts/policy/resource-quotas/)\n- [@article@Leveraging Namespaces for Cost Optimization with Kubernetes](https://thenewstack.io/leveraging-namespaces-for-cost-optimization-with-kubernetes/)\n- [@video@Kubernetes Namespaces Explained in 15 mins](https://www.youtube.com/watch?v=K3jNo4z5Jx8)",
    "autoscaling@03mGA5AyL7mpF6y3EMW7A": "# Autoscaling\n\nAutoscaling in Kubernetes involves adjusting the resources allocated to a deployment or set of pods based on demand. It includes Horizontal Pod Autoscaling (HPA) and Vertical Pod Autoscaling (VPA), which increase or decrease replicas or adjust resource requests and limits, respectively. Autoscaling can be used with Cluster Autoscaling to efficiently allocate resources and ensure application responsiveness. It's useful for handling variable workloads or sudden spikes in traffic.\n\nVisit the following resources to learn more:\n\n- [@official@Autoscaling in Kubernetes](https://kubernetes.io/blog/2016/07/autoscaling-in-kubernetes/)\n- [@video@Kubernetes cluster autoscaling for beginners](https://www.youtube.com/watch?v=jM36M39MA3I)",
    "basics@70lTSIVh0AD6M8fMMuWzY": "# Scheduling Basics\n\nScheduling involves assigning pods to worker nodes based on criteria such as resource availability, labels, affinity/anti-affinity rules, taints, and tolerations. Pods are the smallest deployable units in k8s, consisting of one or more containers that share the same network namespace. The scheduler is responsible for assigning pods to nodes, while labels are used for matching. Affinity and anti-affinity rules dictate how pods are scheduled based on their relationships with other pods or nodes. QoS is used to prioritize pod scheduling based on their resource requirements.\n\nVisit the following resources to learn more:\n\n- [@official@Kubernetes Scheduler](https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/)\n- [@video@How Scheduling in Kubernetes Works](https://www.youtube.com/watch?v=0FvQR-0tK54)",
    "blue-green-deployments@9-oaTlzKmcxTfaRycz1w3": "# Blue Green Deployments\n\nIt is a deployment strategy used in Kubernetes for deploying new versions of an application by running two identical production environments, one with the current version (blue) and the other with the new version (green). After the green environment is fully tested, traffic is routed from the blue environment to the green environment, providing a seamless transition for users and avoiding any downtime or disruption. In Kubernetes, Blue-Green Deployments can be implemented using a variety of tools and techniques, including deployment strategies, traffic routing, and load balancing.\n\nVisit the following resources to learn more:\n\n- [@article@Create a Kubernetes Blue Green Deployment](https://developer.harness.io/docs/continuous-delivery/cd-execution/kubernetes-executions/create-a-kubernetes-blue-green-deployment/)\n- [@video@Kubernetes - Blue/Green Deployments](https://www.youtube.com/watch?v=jxhpTGQ484Y)",
    "canary-deployments@88IGeC3dAopHLGtLozxdY": "# Canary Deployments\n\nCanary Deployments is a technique used in Kubernetes to gradually roll out new versions of an application by directing a small percentage of users or traffic to the new version while the majority continue using the old version. This approach allows for testing the new version under real-world conditions before fully committing to the update. In Kubernetes, canary deployments can be implemented using tools such as Istio, Linkerd, or Nginx, or by using built-in features like deployment strategies and traffic routing.\n\nVisit the following resources to learn more:\n\n- [@article@Canary deployment for K8s deployments](https://learn.microsoft.com/en-us/azure/devops/pipelines/ecosystems/kubernetes/canary-demo?view=azure-devops&tabs=yaml)\n- [@video@Kubernetes canary deployments Explained](https://www.youtube.com/watch?v=sCevTD_GtvU)",
    "choosing-a-managed-provider@qSatCdBTDXPu-IFWzUI99": "# Choosing a Managed Provider\n\nA managed provider is a cloud-based service that provides a managed Kubernetes environment. This means that the provider handles the underlying infrastructure, such as servers, storage, and networking, as well as the installation, configuration, and maintenance of the Kubernetes cluster.\n\nWhen choosing a managed Kubernetes provider, consider the cloud provider you are using, features and capabilities, pricing and billing, support, security and compliance, and the provider's reputation and reviews. By taking these factors into account, you can select a provider that meets your needs and offers the best value for your organization.\n\nVisit the following resources to learn more:\n\n- [@article@Choosing a Managed Kubernetes Provider](https://containerjournal.com/features/choosing-a-managed-kubernetes-provider/)\n- [@article@Amazon Web Services Gears Elastic Kubernetes Service for Batch Work](https://thenewstack.io/amazon-web-services-gears-elastic-kubernetes-service-for-batch-jobs/)\n- [@article@How to Build The Right Platform for Kubernetes](https://thenewstack.io/kubernetes/kubernetes-infrastructure-architecture/)",
    "ci--cd-integration@Pymc9H-lRHVPy7M9eSaPD": "# CI/CD Integration\n\nIn CI/CD pattern, the build, test, and deployment of applications to Kubernetes are fully automated. The CI pipeline creates the container image, runs tests, and pushes it to a registry. The CD pipeline then updates Kubernetes manifests or Helm charts and applies them to the cluster using tools like Argo CD, Flux, or kubectl. This makes deployments consistent, repeatable, and fast.\n\nVisit the following resources to learn more:\n\n- [@article@Kubernetes CI/CD Pipelines â€“ 8 Best Practices and Tools](https://spacelift.io/blog/kubernetes-ci-cd)\n- [@article@8 Kubernetes CI/CD tools every developer should know](https://octopus.com/devops/kubernetes-deployments/kubernetes-ci-cd-tools-for-developers/)",
    "cluster-autoscaling@RC5MoYtG2rom-d4FW5qD2": "# Autoscaling\n\nAutoscaling in Kubernetes involves adjusting the resources allocated to a deployment or set of pods based on demand. It includes Horizontal Pod Autoscaling (HPA) and Vertical Pod Autoscaling (VPA), which increase or decrease replicas or adjust resource requests and limits, respectively. Autoscaling can be used with Cluster Autoscaling to efficiently allocate resources and ensure application responsiveness. It's useful for handling variable workloads or sudden spikes in traffic.\n\nVisit the following resources to learn more:\n\n- [@official@Autoscaling in Kubernetes](https://kubernetes.io/blog/2016/07/autoscaling-in-kubernetes/)\n- [@video@Kubernetes cluster autoscaling for beginners](https://www.youtube.com/watch?v=jM36M39MA3I)",
    "configuration-management@dj7Tb2XTX4kxRUYiTjlhM": "# Secrets\n\nKubernetes secrets store sensitive data such as passwords, tokens, and API keys in a secure manner. They can be created manually or automatically, and stored in etcd. Secrets can be mounted as files or environment variables in a pod, and access can be managed using Kubernetes RBAC. However, they have some limitations, such as size and the inability to be updated once created. Understanding secrets is important for building secure applications in Kubernetes.\n\nVisit the following resources to learn more:\n\n- [@official@Documentation - Secrets](https://kubernetes.io/docs/concepts/configuration/secret/)\n- [@article@Kubernetes Secrets Management: 3 Approaches, 9 Best Practices](https://thenewstack.io/kubernetes-secrets-management-3-approaches-9-best-practices/)\n- [@video@Kubernetes Secrets in 5 Minutes!](https://www.youtube.com/watch?v=cQAEK9PBY8U)",
    "container-and-pod-security@i7qxaFhFHPfe3fGEgsbcE": "# Container and Pod Security\n\nKubernetes (k8s) can secure containers and pods through measures like using trusted container images, limiting container privileges, enforcing pod-level security policies, implementing network security measures, using access controls with RBAC, and managing sensitive information with Secrets and ConfigMaps. These practices help organizations reduce the risk of security incidents in their k8s clusters.\n\nVisit the following resources to learn more:\n\n- [@official@Configure a Security Context for a Pod or Container](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)\n- [@article@Tutorial: Create a Kubernetes Pod Security Policy](https://thenewstack.io/tutorial-create-a-kubernetes-pod-security-policy/)\n- [@article@6 Overlooked Yet Important Kubernetes Features to Secure](https://thenewstack.io/6-overlooked-yet-important-kubernetes-features-to-secure/)\n- [@video@Kubernetes Security - Security Context for a Pod or Container](https://www.youtube.com/watch?v=i8wfvoVf2xs)\n- [@feed@Explore top posts about Security](https://app.daily.dev/tags/security?ref=roadmapsh)",
    "container-and-pod-security@Nja7IFWcFTLsPcqbvRNm9": "# Container and Pod Security\n\nKubernetes (k8s) can secure containers and pods through measures like using trusted container images, limiting container privileges, enforcing pod-level security policies, implementing network security measures, using access controls with RBAC, and managing sensitive information with Secrets and ConfigMaps. These practices help organizations reduce the risk of security incidents in their k8s clusters.\n\nVisit the following resources to learn more:\n\n- [@official@Configure a Security Context for a Pod or Container](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)\n- [@article@Tutorial: Create a Kubernetes Pod Security Policy](https://thenewstack.io/tutorial-create-a-kubernetes-pod-security-policy/)\n- [@article@6 Overlooked Yet Important Kubernetes Features to Secure](https://thenewstack.io/6-overlooked-yet-important-kubernetes-features-to-secure/)\n- [@video@Kubernetes Security - Security Context for a Pod or Container](https://www.youtube.com/watch?v=i8wfvoVf2xs)\n- [@feed@Explore top posts about Security](https://app.daily.dev/tags/security?ref=roadmapsh)",
    "containers@HGmeYvRf7_XusZl_K4x9k": "# Containers\n\nKubernetes is built on containers, so before learning Kubernetes you should be comfortable running and building containers from scratch.\n\nVisit the following resources to learn more:\n\n- [@article@Official Docker Tutorial](https://www.docker.com/101-tutorial/)\n- [@article@Docker Curriculum](https://docker-curriculum.com/)\n- [@video@Docker in 100 Seconds (video)](https://www.youtube.com/watch?v=Gjnup-PuquQ)\n- [@video@Free 3 Hour Video Course on Docker for Beginners](https://www.youtube.com/watch?v=3c-iBn73dDE)\n- [@feed@Explore top posts about Containers](https://app.daily.dev/tags/containers?ref=roadmapsh)",
    "creating-custom-controllers@L9rVPEEXFwisQOwT_LQ4v": "# Custom Controllers\n\nCustom controllers in Kubernetes automate the management of custom resources that are not natively supported by Kubernetes. They are implemented as Kubernetes controllers that watch custom resources and react to changes in their state. Custom resources are created by extending the Kubernetes API with new resource types specific to an organization's needs. Custom controllers can be developed using various programming languages and frameworks, such as the Operator Framework. The Operator Framework provides tools and best practices for developing, testing, and deploying custom controllers.\n\nVisit the following resources to learn more:\n\n- [@official@Custom Controllers](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#custom-controllers)\n- [@video@Extending Kubernetes with Custom Controllers](https://www.youtube.com/results?search_query=Custom+controllers+in+k8s)",
    "csi-drivers@55RV9psPCmcg8G_P_zQo9": "# CSI drivers\n\nCSI (Container Storage Interface) drivers in Kubernetes provide a standard way for storage providers to integrate with Kubernetes and offer persistent storage for containerized applications. They operate as separate containerized processes and communicate with Kubernetes through a well-defined API. CSI drivers allow Kubernetes to access a wide range of storage systems and provide advanced features like snapshotting and cloning.\n\nVisit the following resources to learn more:\n\n- [@official@Container Storage Interface (CSI) for Kubernetes](https://kubernetes.io/blog/2019/01/15/container-storage-interface-ga/)\n- [@video@CSI in Kubernetes](https://www.youtube.com/watch?v=brXPQ1Qwjl4)",
    "custom-resource-definitions-crds@9P7l-RBOkUxs3Z_UpKQO-": "# Custom Resource Definitions\n\nCustom Resource Definitions (CRDs) in Kubernetes extend the Kubernetes API by defining new resource types specific to an organization's needs. CRDs create custom resources that can manage a wide variety of resources, such as applications, databases, storage, and networking. They are defined using YAML or JSON manifests and can be created and managed using the Kubernetes API server. Once created, custom resources can be managed using Kubernetes controllers and integrated with other Kubernetes components. CRDs are a powerful tool for streamlining operations in Kubernetes and enabling organizations to manage resources in a more efficient and customized way.\n\nVisit the following resources to learn more:\n\n- [@official@Custom Resources - Documentation](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/)\n- [@video@Custom Resource Definition (CRD) Explained with Demo](https://www.youtube.com/watch?v=u1X5Rf7fWwM)",
    "custom-schedulers-and-extenders@1-Nb8rCMJEZrYm20sEcRJ": "# Custom Schedulers Extenders\n\nCustom Scheduler Extenders in Kubernetes enhance the scheduling capabilities of Kubernetes by allowing users to define their own scheduling logic based on custom metrics and constraints. They are implemented as custom Kubernetes controllers that run alongside the Kubernetes scheduler. Custom Scheduler Extenders can be used to implement scheduling policies specific to an organization's needs and can be developed using various programming languages. They intercept scheduling requests, add custom scheduling logic based on user-defined rules, and pass requests back to the Kubernetes scheduler.\n\nVisit the following resources to learn more:\n\n- [@article@Create a custom Kubernetes scheduler](https://developer.ibm.com/articles/creating-a-custom-kube-scheduler/)\n- [@video@Custom Scheduler Kubernetes | Multiple Schedulers Kubernetes](https://www.youtube.com/watch?v=NiB7sjXmiZc)",
    "deploying-your-first-application@zrbSJa3k7a3TE0aYbWi9c": "# Deploying your First Application\n\nTo deploy your first application in Kubernetes, you need to create a deployment and service manifest in YAML files, apply the manifests to your Kubernetes cluster using the kubectl apply command, verify that your application's pods are running with kubectl get pods, and test the service with kubectl get services and accessing the service using a web browser or a tool like cURL. There are also various tools and platforms available that can simplify application deployment in Kubernetes, such as Helm charts and Kubernetes operators.\n\nVisit the following resources to learn more:\n\n- [@official@Using kubectl to Create a Deployment](https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/)\n- [@article@Deploying An Application On Kubernetes From A to Z](https://web.archive.org/web/20230326150953/https://www.weave.works/blog/deploying-an-application-on-kubernetes-from-a-to-z)\n- [@article@Kubernetes 101: Deploy Your First Application with MicroK8s](https://thenewstack.io/kubernetes-101-deploy-your-first-application-with-microk8s/)\n- [@video@Kubernetes Tutorial | Your First Kubernetes Application](https://www.youtube.com/watch?v=Vj6EFnav5Mg)\n- [@video@Kubernetes 101: Deploying Your First Application](https://www.youtube.com/watch?v=XltFOyGanYE)",
    "deployment-patterns@0l0xpsabglvs_t6oAP-XG": "# Blue Green Deployments\n\nIt is a deployment strategy used in Kubernetes for deploying new versions of an application by running two identical production environments, one with the current version (blue) and the other with the new version (green). After the green environment is fully tested, traffic is routed from the blue environment to the green environment, providing a seamless transition for users and avoiding any downtime or disruption. In Kubernetes, Blue-Green Deployments can be implemented using a variety of tools and techniques, including deployment strategies, traffic routing, and load balancing.\n\nVisit the following resources to learn more:\n\n- [@article@Create a Kubernetes Blue Green Deployment](https://developer.harness.io/docs/continuous-delivery/cd-execution/kubernetes-executions/create-a-kubernetes-blue-green-deployment/)\n- [@video@Kubernetes - Blue/Green Deployments](https://www.youtube.com/watch?v=jxhpTGQ484Y)",
    "deployments@TUGQX7y1gs-aKPge2F1NU": "# Deployments\n\nA Deployment is a resource object for managing Pods and ReplicaSets via a declarative configuration, which define a desired state that describes the application workload life cycle, number of pods, deployment strategies, container images, and more. The Deployment Controller works to ensure the actual state matches desired state, such as by replacing a failed pod. Out of the box, Deployments support several deployment strategies, like \"recreate\" and \"rolling update\", however can be customized to support more advanced deployment strategies such as blue/green or canary deployments.\n\nVisit the following resources to learn more:\n\n- [@official@Deployments Documentation](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)\n- [@article@Kubernetes Deployment: From Basic Strategies to Progressive Delivery\n](https://codefresh.io/learn/kubernetes-deployment/)\n- [@video@Kubernetes Deployments | Deployment Strategies](https://youtu.be/lxc4EXZOOvE)",
    "evictions@TRKzlDW2PQN9bWTyz3NWL": "# Evictions\n\nEvictions terminate or delete running pods from a node due to reasons like resource constraints or pod failures. They can be initiated by the system or administrators manually through the API. Evictions can be graceful, allowing pods to clean up resources, or forceful, immediately terminating them. Kubernetes provides preemption and pod disruption budgets to handle evictions effectively and minimize service disruptions. Evictions are necessary to manage and maintain Kubernetes clusters, and Kubernetes provides tools to handle them.\n\nVisit the following resources to learn more:\n\n- [@official@Node-pressure Eviction](https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/)\n- [@official@API-initiated Eviction](https://kubernetes.io/docs/concepts/scheduling-eviction/api-eviction/)",
    "external-access-to-services@jUOlITLqnIvSu97I_3nBz": "# External Access to Services\n\nExternal access to Kubernetes (k8s) Services allows external clients to access pods and services running in the cluster. There are multiple ways to enable external access to Services in k8s, including NodePorts, LoadBalancers, and Ingress. Ingress is a Kubernetes object that provides a flexible way to manage external access, routing traffic to Services based on URL or host. External access is essential to ensure the scalability and reliability of Kubernetes deployments.\n\nVisit the following resources to learn more:\n\n- [@official@Ingress - Documentation](https://kubernetes.io/docs/concepts/services-networking/ingress/)\n- [@article@Kubernetes Ingress for Beginners](https://thenewstack.io/kubernetes-ingress-for-beginners/)\n- [@video@How do I provide external access to Kubernetes services](https://www.youtube.com/watch?v=iBYTFpoXx24)",
    "gitops@dATdEyNWlpDNKjedCXLyb": "# GitOps\n\nGitOps is a set of practices for managing infrastructure and applications using Git repositories as the source of truth for declarative configuration. In Kubernetes, GitOps involves using Git as the single source of truth for both the desired and actual state of the system, automating deployment and management tasks, and often using it in conjunction with Continuous Delivery (CD) practices. The result is a more consistent, reliable, and automated approach to managing infrastructure and applications.\n\nVisit the following resources to learn more:\n\n- [@article@Using GitOps with a Kubernetes cluster](https://docs.gitlab.com/ee/user/clusters/agent/gitops.html)\n- [@video@DevOps and GitOps for Kubernetes](https://www.youtube.com/watch?v=PFLimPh5-wo)\n- [@feed@Explore top posts about GitOps](https://app.daily.dev/tags/gitops?ref=roadmapsh)",
    "helm-charts@FAEFOhLdp7xrmctHFxiOM": "# Helm Charts\n\nHelm is a Kubernetes package manager that simplifies the deployment and management of complex applications through the use of reusable and versioned Helm charts. These charts are composed of YAML files that describe related sets of Kubernetes resources and can be customized using values files and templating with Go templates. Helm charts can also have dependencies on other charts and be stored in a centralized repository like Helm Hub for easy sharing and access. By utilizing Helm, teams can streamline application management and reduce duplication of effort.\n\nVisit the following resources to learn more:\n\n- [@official@Helm Docs](https://helm.sh/docs/)\n- [@video@What is Helm in Kubernetes? Helm and Helm Charts explained](https://www.youtube.com/watch?v=-ykwb1d0DXU)\n- [@feed@Explore top posts about Helm](https://app.daily.dev/tags/helm?ref=roadmapsh)",
    "horizontal-pod-autoscaler-hpa@044IUUCgZP4oQ9UxUG2iy": "# Horizontal Pod Autoscaler\n\nIt is a feature in Kubernetes that automatically scales the number of replicas of a pod based on the current demand for the workload it is running. The HPA controller monitors the CPU utilization or other metrics of the pod and adjusts the number of replicas of the pod to meet the specified target. This helps to ensure that the workload can handle increases in traffic and demand without overloading the resources of the cluster.\n\nVisit the following resources to learn more:\n\n- [@official@Horizontal Pod Autoscaling - Documentation](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)",
    "injecting-pod-config-with-configmaps@u24UlZKI86vaguj_VpMv1": "# ConfigMaps\n\nConfigMaps are a way to store configuration data that can be used by applications running in the cluster. A Config Map is a key-value store that can hold configuration data such as database URLs, credentials, API keys, or any other application configuration data that can be used by the application.\n\nVisit the following resources to learn more:\n\n- [@official@ConfigMaps Documentation](https://kubernetes.io/docs/concepts/configuration/configmap/)\n- [@article@Kubernetes CRDs: What They Are and Why They Are Useful](https://thenewstack.io/kubernetes-crds-what-they-are-and-why-they-are-useful/)\n- [@video@Tutorial - ConfigMap in Kubernetes](https://www.youtube.com/watch?v=BPrC_lgmcHQ)",
    "installing-a-local-cluster@YaIs8lquWIe1D7RCUBZmC": "# Installing a Local Cluster\n\nTo install and configure a Kubernetes cluster on CentOS 7 or Ubuntu, you would need to setup the prerequisites and requirements for setting up a Kubernetes cluster after which you would be installing the Kubernetes components, including Kubeadm, Kubelet, and Kubectl and then you'll need to connect the master and the worker nodes. Once the connection is established you can check it by deploying application on the cluster.\n\nVisit the following resources to learn more:\n\n- [@article@How to Install a Kubernetes Cluster on CentOS 7](https://www.tecmint.com/install-kubernetes-cluster-on-centos-7/)\n- [@article@How To Create a Kubernetes Cluster Using on Ubuntu](https://www.digitalocean.com/community/tutorials/how-to-create-a-kubernetes-cluster-using-kubeadm-on-ubuntu-20-04)\n- [@article@Deploy a Kubernetes Cluster on Ubuntu Server with Microk8s](https://thenewstack.io/deploy-a-kubernetes-cluster-on-ubuntu-server-with-microk8s/)",
    "installing-the-control-plane@M-iTb_7EWZIJ3JpdViICx": "# Control Plane Installation\n\nThe control plane's components make global decisions about the cluster (for example, scheduling), as well as detecting and responding to cluster events (for example, starting up a new pod when a deployment's replicas field is unsatisfied). Control plane components can be run on any machine in the cluster. However, for simplicity, set up scripts typically start all control plane components on the same machine, and do not run user containers on this machine.\n\nVisit the following resources to learn more:\n\n- [@official@Initializing your control-plane node - Documentation](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#initializing-your-control-plane-node)\n- [@video@Tutorial - Install Control Plane Components](https://www.youtube.com/watch?v=IUwuyZ5ReF0)",
    "introduction@y7KjVfSI6CAduyHd4mBFT": "# Kubernetes Introduction\n\nKubernetes is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications. It provides a way to abstract the underlying infrastructure and manage applications at scale, while also offering flexibility, portability, and a rich feature set. Kubernetes has become the de facto standard for container orchestration due to its widespread adoption, active community, and ability to handle complex, multi-tiered applications.\n\nVisit the following resources to learn more:\n\n- [@official@Kubernetes Documentation](https://kubernetes.io/)\n- [@article@Introduction of Kubernetes](https://www.digitalocean.com/community/tutorials/an-introduction-to-kubernetes)\n- [@video@Kubernetes Tutorial for Beginners](https://www.youtube.com/watch?v=X48VuDVv0do)\n- [@feed@Explore top posts about Kubernetes](https://app.daily.dev/tags/kubernetes?ref=roadmapsh)",
    "jobs@r3fzAN5DzratAKnnT8hzb": "# Jobs\n\na Job is a controller that manages the execution of a finite task or batch job. Jobs are used to run short-lived tasks, such as batch processing, data analysis, or backups, that run to completion and then terminate. Jobs create one or more pods to run the task, and they monitor the completion status of each pod. If a pod fails or terminates, the Job automatically creates a replacement pod to ensure that the task is completed successfully. Jobs are defined by a YAML file that includes a pod template, completion criteria, and other settings.\n\nVisit the following resources to learn more:\n\n- [@official@Jobs Documentation](https://kubernetes.io/docs/concepts/workloads/controllers/job/)\n- [@article@How Kubernetes Is Transforming into a Universal Scheduler](https://thenewstack.io/how-kubernetes-is-transforming-into-a-universal-scheduler/)\n- [@video@Tutorial | Jobs in Kubernetes](https://www.youtube.com/watch?v=j1EnBbxSz64)",
    "key-concepts-and-terminologies@9oo2fxTM2_p0VYPBroqxa": "# Key Concepts Terminologies\n\nKubernetes is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications. Here are some important concepts and terminologies in Kubernetes:\n\n*   Cluster Architecture: The architectural concepts behind Kubernetes.\n*   Containers: Technology for packaging an application along with its runtime dependencies.\n*   Workloads: Understand Pods, the smallest deployable compute object in Kubernetes, and the higher-level abstractions that help you to run them.\n*   Services, Load Balancing, and Networking: Concepts and resources behind networking in Kubernetes.\n*   Storage: Ways to provide both long-term and temporary storage to Pods in your cluster.\n*   Configuration: Resources that Kubernetes provides for configuring Pods.\n*   Cluster Administration: Lower-level detail relevant to creating or administering a Kubernetes cluster.\n\nVisit the following resources to learn more:\n\n- [@official@Concepts of Kubernetes](https://kubernetes.io/docs/concepts/)\n- [@article@Understand Kubernetes terminology](https://about.gitlab.com/blog/2020/07/30/kubernetes-terminology/)\n- [@video@What Is Kubernetes?](https://www.youtube.com/watch?v=QJ4fODH6DXI)\n- [@video@Kubernetes Explained by Experts in 2 Minutes](https://youtu.be/XfBrtNZ2OCw)",
    "kubernetes-alternatives@3fzuXKH7az_LVnmnoXB1p": "# Kubernetes Alternatives\n\nKubernetes is a popular open-source container orchestration tool that is widely used for managing and deploying containerized applications. While there are other container orchestration tools available, such as Docker Swarm, Mesos, and Nomad, there are some key differences between Kubernetes and these other tools and some of them are mentioned below:\n\n*   Architecture: Kubernetes is designed as a modular system with many components that work together to provide container orchestration, such as the Kubernetes API server, kubelet, kube-proxy, and etcd.\n*   Scalability: Kubernetes is designed to handle large-scale deployments and can scale applications up or down based on demand.\n*   Flexibility: Kubernetes is highly configurable and can be customized to meet specific requirements, whereas other container orchestration tools may have more limited configuration options.\n*   Portability: Kubernetes is designed to be cloud-agnostic and can run on any public or private cloud platform, as well as on-premises.\n*   Community: Kubernetes has a large and active community of developers and users who contribute to its development and provide support.\n\nVisit the following resources to learn more:\n\n- [@article@Compare Apache Mesos vs. Kubernetes](https://www.techtarget.com/searchitoperations/tip/Compare-container-orchestrators-Apache-Mesos-vs-Kubernetes)\n- [@article@Docker Swarm, a User-Friendly Alternative to Kubernetes](https://thenewstack.io/docker-swarm-a-user-friendly-alternative-to-kubernetes/)\n- [@article@Can You Live without Kubernetes?](https://thenewstack.io/can-you-live-without-kubernetes/)\n- [@feed@Explore top posts about Kubernetes](https://app.daily.dev/tags/kubernetes?ref=roadmapsh)",
    "kubernetes-extensions-and-apis@UeJcKv3jhenjNzHM-0R86": "# Kubernetes Extensions and APIs\n\nKubernetes (k8s) extensions and APIs are used to customize the behavior of Kubernetes and add new capabilities to the system. Kubernetes extensions, including Custom Resource Definitions (CRDs), Custom Controllers, Custom Scheduler Extenders, and Custom Metrics APIs, enhance Kubernetes functionality. Kubernetes APIs are used to manage resources in a Kubernetes cluster and interact with the system. Kubernetes extensions and APIs together provide a powerful toolkit for customizing and extending Kubernetes, enabling users to build custom components and APIs that streamline operations in Kubernetes.\n\nVisit the following resources to learn more:\n\n- [@official@Extensions - Documentation](https://kubernetes.io/docs/concepts/extend-kubernetes/#extensions)\n- [@official@The Kubernetes API - Documentation](https://kubernetes.io/docs/concepts/overview/kubernetes-api/)\n- [@feed@Explore top posts about Kubernetes](https://app.daily.dev/tags/kubernetes?ref=roadmapsh)",
    "load-balancing@Qelo1YvAcUoX5PA-RYbNp": "# Load Balancing\n\nLoad balancing in distributes network traffic across multiple pods or nodes using a Service object. A Service provides a stable network endpoint for a set of pods, allowing other pods or external clients to access them through a single IP address and DNS name. Kubernetes offers three types of load balancing algorithms for Services, which distribute traffic based on round-robin, least connections, or IP hash. Load balancing is an essential part of Kubernetes networking, providing efficient and reliable traffic distribution across a cluster.\n\nVisit the following resources to learn more:\n\n- [@official@Load Balancing - Documentation](https://kubernetes.io/docs/concepts/services-networking/ingress/#load-balancing)\n- [@article@Ingress Controllers: The Swiss Army Knife of Kubernetes](https://thenewstack.io/ingress-controllers-the-swiss-army-knife-of-kubernetes/)\n- [@video@Tutorial | Load Balancing Service in Kubernetes](https://www.youtube.com/watch?v=xCsz9IOt-fs)",
    "logs@-XxQtiLDAkXs7IFM_Ddw6": "# Logs\n\nLogs are generated by containerized applications running on nodes within the cluster. You can access these logs using the kubectl logs command followed by the name of the pod. By default, this command shows the logs from the most recent container in the pod, but you can specify a specific container within the pod by adding the container name to the command. Adding the -f flag to the command allows you to follow the logs in real-time. There are also third-party logging solutions available for Kubernetes, such as the EFK and Prometheus stacks, that provide more advanced logging capabilities and scalability for large-scale applications.\n\nVisit the following resources to learn more:\n\n- [@official@System Logs](https://kubernetes.io/docs/concepts/cluster-administration/system-logs/)\n- [@video@Kubernetes: Log collection explained](https://www.youtube.com/watch?v=6kmHvXdAzIM)",
    "metrics@nqUBHBFUYFdYqCKZvfXBR": "# Metrics\n\nMetrics to monitor include CPU usage, memory usage, network usage, disk usage, API server metrics, pod and container metrics, and cluster-level metrics. These metrics provide insights into the performance and health of the cluster, nodes, and applications running on the cluster. Kubernetes provides tools such as Prometheus, Grafana, and Kubernetes Dashboard for collecting and analyzing these metrics. By monitoring these metrics, administrators can identify performance issues and optimize the cluster for better performance and scalability.\n\nVisit the following resources to learn more:\n\n- [@official@Node Metrics Data](https://kubernetes.io/docs/reference/instrumentation/node-metrics/)\n- [@video@How to collect metrics in K8s?](https://www.youtube.com/watch?v=JQrk6HwlN78)",
    "monitoring--optimizing-resource-usage@PP4ld_vvjpY3QltBBsXKD": "# Kuberenetes\n\nKubernetes, also known as K8s, is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications. It allows developers to focus on writing code while Kubernetes handles the underlying infrastructure. Kubernetes uses declarative configuration files to specify the desired state of an application, and can automatically scale applications based on demand, handle failovers, and manage networking and storage. It is widely used in cloud-native architectures that rely on microservices and containers for production deployments.\n\nVisit the following resources to learn more:\n\n- [@official@Overview of Kubernetes](https://kubernetes.io/docs/concepts/overview/)\n- [@video@Kubernetes Explained in 100 Seconds](https://www.youtube.com/watch?v=PziYflu8cB8)\n- [@video@Kubernetes Tutorial for Beginners](https://www.youtube.com/watch?v=X48VuDVv0do&t=1s)",
    "monitoring-and-logging@AgsQnQjyTLUFhFpRdcE13": "# Observability Engines\n\nObservability in Kubernetes (k8s) refers to the ability to gain insight into the inner workings of your cluster, applications, and services running on top of it. An observability engine in k8s is a tool or platform that facilitates the collection, analysis, and visualization of data from various sources in your k8s environment. Some popular observability engines in k8s include Prometheus, Grafana, Jaeger, and Elastic Stack (ELK).\n\nVisit the following resources to learn more:\n\n- [@opensource@K8sGPT - AI scanner for Kubernetes problems](https://github.com/k8sgpt-ai/k8sgpt)\n- [@opensource@HolmesGPT - AIOps Platform for investigating Kubernetes problems and Prometheus alerts](https://github.com/robusta-dev/holmesgpt/)\n- [@article@Kubernetes Observability 101: Tools, Best Practices, And More](https://www.cloudzero.com/blog/kubernetes-observability)\n- [@article@Kubernetes Observability in KubeSphere](https://kubesphere.io/observability/)\n- [@feed@Explore top posts about Observability](https://app.daily.dev/tags/observability?ref=roadmapsh)",
    "multi-cluster-management@auZgEQ6FC3nUjuyx0zANh": "# Multi Cluster Management\n\nMulti-Cluster Management in Kubernetes (k8s) refers to the ability to manage multiple Kubernetes clusters using a single control plane. This approach allows administrators to centrally manage and orchestrate resources across multiple clusters, regardless of where they are located, without having to switch between multiple management consoles or tools.\n\nVisit the following resources to learn more:\n\n- [@official@Configure Access to Multiple Clusters - Documentation](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/)\n- [@video@Kubernetes Cluster Management Strategies](https://www.youtube.com/watch?v=966TJ6mlOYY)",
    "network-security@s0gHg8CqwrSylpSPu8arA": "# Network Security\n\nNetwork security in Kubernetes involves securing network communication between different components within the cluster and with external networks. This can be achieved through various mechanisms such as Network Policies, Encryption, Authentication, Authorization, and Firewall rules. Network Policies provide fine-grained control over network traffic, while encryption ensures secure communication between pods, nodes, and external systems. Authentication and Authorization mechanisms prevent unauthorized access and provide secure communication between various components. Firewall rules help to protect the cluster against external attacks by limiting access to specific ports and protocols. Overall, network security in Kubernetes is critical to maintaining the confidentiality, integrity, and availability of the cluster.\n\nVisit the following resources to learn more:\n\n- [@official@Network Policies - Documentation](https://kubernetes.io/docs/concepts/services-networking/network-policies/)\n- [@article@6 Kubernetes Security Best Practices](https://thenewstack.io/6-kubernetes-security-best-practices/)\n- [@article@The Kubernetes Network Security Effect](https://thenewstack.io/the-kubernetes-network-security-effect/)\n- [@article@Kubernetes Security Best Practices to Keep You out of the News](https://thenewstack.io/kubernetes-security-best-practices-to-keep-you-out-of-the-news/)\n- [@video@Kubernetes Security Best Practices](https://www.youtube.com/watch?v=oBf5lrmquYI)\n- [@feed@Explore top posts about Security](https://app.daily.dev/tags/security?ref=roadmapsh)",
    "networking--pod-to-pod-communication@44rhdieUCWsGFC_1__9kk": "# Kuberenetes\n\nKubernetes, also known as K8s, is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications. It allows developers to focus on writing code while Kubernetes handles the underlying infrastructure. Kubernetes uses declarative configuration files to specify the desired state of an application, and can automatically scale applications based on demand, handle failovers, and manage networking and storage. It is widely used in cloud-native architectures that rely on microservices and containers for production deployments.\n\nVisit the following resources to learn more:\n\n- [@official@Overview of Kubernetes](https://kubernetes.io/docs/concepts/overview/)\n- [@video@Kubernetes Explained in 100 Seconds](https://www.youtube.com/watch?v=PziYflu8cB8)\n- [@video@Kubernetes Tutorial for Beginners](https://www.youtube.com/watch?v=X48VuDVv0do&t=1s)",
    "observability-engines@FANswgUhUb5Iuah2fni3L": "# Observability Engines\n\nObservability in Kubernetes (k8s) refers to the ability to gain insight into the inner workings of your cluster, applications, and services running on top of it. An observability engine in k8s is a tool or platform that facilitates the collection, analysis, and visualization of data from various sources in your k8s environment. Some popular observability engines in k8s include Prometheus, Grafana, Jaeger, and Elastic Stack (ELK).\n\nVisit the following resources to learn more:\n\n- [@opensource@K8sGPT - AI scanner for Kubernetes problems](https://github.com/k8sgpt-ai/k8sgpt)\n- [@opensource@HolmesGPT - AIOps Platform for investigating Kubernetes problems and Prometheus alerts](https://github.com/robusta-dev/holmesgpt/)\n- [@article@Kubernetes Observability 101: Tools, Best Practices, And More](https://www.cloudzero.com/blog/kubernetes-observability)\n- [@article@Kubernetes Observability in KubeSphere](https://kubesphere.io/observability/)\n- [@feed@Explore top posts about Observability](https://app.daily.dev/tags/observability?ref=roadmapsh)",
    "overview-of-kubernetes@qLeEEwBvlGt1fP5Qcreah": "# Kubernetes overview\n\nKubernetes is a portable, extensible, open source platform for managing containerized workloads and services, that facilitates both declarative configuration and automation. It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools are widely available.\n\nThe name Kubernetes originates from Greek, meaning helmsman or pilot. K8s as an abbreviation results from counting the eight letters between the \"K\" and the \"s\". Google open-sourced the Kubernetes project in 2014. Kubernetes combines over 15 years of Google's experience running production workloads at scale with best-of-breed ideas and practices from the community.\n\nVisit the following resources to learn more:\n\n- [@official@Overview of Kubernetes](https://kubernetes.io/docs/concepts/overview/)\n- [@article@What is Kubernetes?](https://www.redhat.com/en/topics/containers/what-is-kubernetes)\n- [@article@Kubernetes Overview & Essential Reading](https://thenewstack.io/kubernetes/)\n- [@video@Tutorial - Kubernetes](https://www.youtube.com/watch?v=VnvRFRk_51k&t=1sn)\n- [@feed@Explore top posts about Kubernetes](https://app.daily.dev/tags/kubernetes?ref=roadmapsh)",
    "pod-priorities@_Gva1eGcYqpmZNPyV03lt": "# Pod Priorities\n\nPod priorities in Kubernetes determine the order in which pods are scheduled on nodes when there are competing demands for resources. Each pod is assigned a numeric priority value, with higher values indicating higher priority. The scheduler maximizes the total priority of scheduled pods while also considering node suitability, taints and tolerations, and affinity and anti-affinity rules. Priorities can be set manually or automatically based on business logic or application requirements. Priorities help ensure that critical workloads receive necessary resources and are scheduled first, while lower priority workloads are scheduled when resources become available.\n\nVisit the following resources to learn more:\n\n- [@official@Pod priority - Documentation](https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#pod-priority)\n- [@video@Kubernetes Pod Priority (Examples)](https://www.youtube.com/watch?v=sR_Zmvme3-0)",
    "pods@-d2PIXm0V_Iehe8cws8zK": "# Pods\n\nIn Kubernetes, a pod is the smallest deployable unit that represents a single instance of a running process in a cluster. A pod can contain one or more containers that share the same network namespace and can access the same storage volumes. Pods are created and managed by Kubernetes, and they are scheduled to run on one of the nodes in the cluster. Pods provide a lightweight and flexible abstraction layer that enables Kubernetes to manage the deployment, scaling, and networking of containerized applications. Pods also facilitate the communication and data exchange between containers running in the same pod.\n\nVisit the following resources to learn more:\n\n- [@official@Pods Documentation](https://kubernetes.io/docs/concepts/workloads/pods/)\n- [@article@The Kubernetes Way: Pods and Services](https://thenewstack.io/kubernetes-way-part-one/)\n- [@article@5 Best Practices for Configuring Kubernetes Pods Running in Production](https://thenewstack.io/5-best-practices-for-configuring-kubernetes-pods-running-in-production/)\n- [@video@What is a Pod in kubernetes ? Why do you need it ?](https://www.youtube.com/watch?v=k0fzMZgpp14)",
    "replicasets@IF09l0-pryGpMbDt__ocr": "# ReplicaSets\n\nA ReplicaSet is a controller that ensures a specified number of replicas (identical copies) of a pod are running in a cluster at all times. ReplicaSets help to ensure high availability and scalability by automatically scaling the number of pod replicas up or down in response to changes in demand or hardware failures. They are defined by a YAML file that specifies the desired number of replicas, the pod template to use, and other settings. They are responsible for monitoring the status of pods and creating or deleting replicas as necessary to meet the desired state.\n\nVisit the following resources to learn more:\n\n- [@official@ReplicaSet Documentation](https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/)\n- [@article@Strategies for Running Stateful Workloads in Kubernetes: Pet Sets](https://thenewstack.io/strategies-running-stateful-applications-kubernetes-pet-sets/)\n- [@video@ReplicaSet in Kubernetes](https://www.youtube.com/watch?v=1WM-LsH6tKc)",
    "resource-health@pDjNsK5vI9FmKZbQm0lDP": "# Resource Health\n\nResource health monitoring in Kubernetes involves monitoring the health and availability of resources such as pods, nodes, and containers. It helps administrators identify and troubleshoot issues that may affect the system's performance and availability using tools such as Kubernetes Dashboard, Prometheus, or Grafana. Resource health monitoring also helps ensure that the system is resilient to failures and can recover quickly from any disruptions. It is an important part of managing a Kubernetes cluster and ensures the reliability, availability, and scalability of the system.\n\nVisit the following resources to learn more:\n\n- [@video@Dashboards with Grafana and Prometheus](https://www.youtube.com/watch?v=fzny5uUaAeY)\n- [@video@How to Monitor a Kubernetes Cluster with Prometheus & Grafana](https://www.youtube.com/watch?v=YDtuwlNTzRc)",
    "resource-management@eWKkdiBhD5x2sGYajmHEs": "# Monitoring and Optimizing Resource Usage\n\nMonitoring and optimizing resource usage in Kubernetes (k8s) is crucial for ensuring efficient and effective use of resources. To monitor resource usage, k8s provides a Metrics Server, and Prometheus can be integrated with k8s. The Container Runtime Interface (CRI) can also be used to monitor container-level resource usage data. To optimize resource usage, setting appropriate requests and limits, using Horizontal Pod Autoscaling (HPA), implementing pod affinity and anti-affinity rules, and controlling node selection can all help reduce resource contention and improve resource utilization. By monitoring and optimizing resource usage, k8s can ensure that applications run efficiently and resources are used effectively.\n\nVisit the following resources to learn more:\n\n- [@official@Tools for Monitoring Resources - Documentation](https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-usage-monitoring/)\n- [@article@Kubernetes Resource Optimization: Just The Basics](https://sequoia.makes.software/kubernetes-resource-optimization-just-the-basics/)\n- [@article@How to Choose the Right Kubernetes Monitoring Tool ](https://thenewstack.io/how-to-choose-the-right-kubernetes-monitoring-tool/)\n- [@feed@Explore top posts about Monitoring](https://app.daily.dev/tags/monitoring?ref=roadmapsh)",
    "role-based-access-control-rbac@jOq0WwLrq8tlmOgo64QDc": "# Role Based Acccess Control\n\nRole-Based Access Control (RBAC) is a method of controlling access to Kubernetes resources based on the roles assigned to users or groups. RBAC involves creating roles and binding them to users or groups to control access to Kubernetes resources. Roles are defined as a set of rules that determine what actions can be performed on specific resources. By assigning roles to users or groups, access to Kubernetes resources can be restricted or granted based on the permissions defined in the role. RBAC helps ensure the security and integrity of Kubernetes clusters by limiting access to authorized users and groups.\n\nVisit the following resources to learn more:\n\n- [@official@Role Based Access Control Good Practices](https://kubernetes.io/docs/concepts/security/rbac-good-practices/)\n- [@article@A Primer on Kubernetes Access Control](https://thenewstack.io/a-primer-on-kubernetes-access-control/)\n- [@article@A Practical Approach to Understanding Kubernetes Authorization](https://thenewstack.io/a-practical-approach-to-understanding-kubernetes-authorization/)\n- [@article@3 Realistic Approaches to Kubernetes RBAC](https://thenewstack.io/three-realistic-approaches-to-kubernetes-rbac/)\n- [@article@Role-Based Access Control: Five Common Authorization Patterns](https://thenewstack.io/role-based-access-control-five-common-authorization-patterns/)\n- [@article@Securing Kubernetes and Other Resources at Scale Using RBAC](https://thenewstack.io/securing-kubernetes-and-other-resources-at-scale-using-rbac/)\n- [@video@Understand Role Based Access Control in Kubernetes](https://www.youtube.com/watch?v=G3R24JSlGjY)",
    "rolling-updates--rollbacks@yMSXdwDO36CLtp2TBC7aB": "# Kuberenetes\n\nKubernetes, also known as K8s, is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications. It allows developers to focus on writing code while Kubernetes handles the underlying infrastructure. Kubernetes uses declarative configuration files to specify the desired state of an application, and can automatically scale applications based on demand, handle failovers, and manage networking and storage. It is widely used in cloud-native architectures that rely on microservices and containers for production deployments.\n\nVisit the following resources to learn more:\n\n- [@official@Overview of Kubernetes](https://kubernetes.io/docs/concepts/overview/)\n- [@video@Kubernetes Explained in 100 Seconds](https://www.youtube.com/watch?v=PziYflu8cB8)\n- [@video@Kubernetes Tutorial for Beginners](https://www.youtube.com/watch?v=X48VuDVv0do&t=1s)",
    "running-applications@1MdrzhktCWjpmxiYYBdz7": "# Deployments\n\nA Deployment is a resource object for managing Pods and ReplicaSets via a declarative configuration, which define a desired state that describes the application workload life cycle, number of pods, deployment strategies, container images, and more. The Deployment Controller works to ensure the actual state matches desired state, such as by replacing a failed pod. Out of the box, Deployments support several deployment strategies, like \"recreate\" and \"rolling update\", however can be customized to support more advanced deployment strategies such as blue/green or canary deployments.\n\nVisit the following resources to learn more:\n\n- [@official@Deployments Documentation](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)\n- [@article@Kubernetes Deployment: From Basic Strategies to Progressive Delivery\n](https://codefresh.io/learn/kubernetes-deployment/)\n- [@video@Kubernetes Deployments | Deployment Strategies](https://youtu.be/lxc4EXZOOvE)",
    "scheduling@xZDXM_8qb4VL15tNGG0ws": "# Scheduling\n\nScheduling in Kubernetes refers to the process of assigning workloads to specific nodes in a cluster. The Kubernetes scheduler makes scheduling decisions based on factors such as resource availability, node suitability, and workload priorities. It balances workloads across the cluster to ensure efficient resource utilization and avoid overloading nodes. Scheduling takes into account factors such as geographic location, hardware requirements, and application-specific needs.\n\nVisit the following resources to learn more:\n\n- [@official@Kubernetes Scheduler](https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/)\n- [@official@Scheduling Framework](https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/)",
    "security@SG3wtV2rt9nmLEkgrp_zP": "# Security Scanners\n\nKubernetes security scanners help identify vulnerabilities and potential security threats in container images before deployment. Popular options include Aqua Security, Twistlock, Sysdig Secure, Trivy, Anchore Engine, and OpenSCAP. These scanners offer a variety of features such as vulnerability scanning, compliance checks, and runtime protection for Kubernetes environments. By integrating these scanners into their pipelines, organizations can ensure the security and integrity of their Kubernetes deployments and minimize the risk of security breaches and data loss.\n\nVisit the following resources to learn more:\n\n- [@article@8+ open-source Kubernetes vulnerability scanners](https://techbeacon.com/security/8-open-source-kubernetes-vulnerability-scanners-consider)\n- [@article@7 Kubernetes Security Scanners](https://thechief.io/c/editorial/7-kubernetes-security-scanners-to-use-in-your-devsecops-pipeline/)\n- [@article@Improve Security With Automated Image Scanning Through CI/CD](https://thenewstack.io/improve-security-with-automated-image-scanning-through-ci-cd/)\n- [@article@Starboard: Putting all the Kubernetes Security Pieces into One Place](https://thenewstack.io/starboard-putting-all-the-kubernetes-security-pieces-into-one-place/)\n- [@feed@Explore top posts about Security](https://app.daily.dev/tags/security?ref=roadmapsh)",
    "services-and-networking@aUJ_w2L8nxNq3DfAW97Gd": "# Networking and Pod to Pod Communication\n\nNetworking is crucial for communication between pods and resources in a Kubernetes cluster. Each pod has a unique IP address and can communicate with other pods directly. Container networking interface (CNI) plugins are used to configure pod network interfaces and provide isolation between pods. Kubernetes also provides networking services such as load balancing, service discovery, and ingress, which enable external traffic to access pods and services. These services are implemented using Kubernetes objects such as Services, Ingress, and NetworkPolicies. Networking and pod-to-pod communication are essential for scalability, reliability, and flexibility in Kubernetes clusters.\n\nVisit the following resources to learn more:\n\n- [@official@Cluster Networking - Documentation](https://kubernetes.io/docs/concepts/cluster-administration/networking/)\n- [@official@Job with Pod-to-Pod Communication](https://kubernetes.io/docs/tasks/job/job-with-pod-to-pod-communication/)\n- [@article@How Kubernetes Provides Networking and Storage to Applications](https://thenewstack.io/how-kubernetes-provides-networking-and-storage-to-applications/)\n- [@feed@Explore top posts about Networking](https://app.daily.dev/tags/networking?ref=roadmapsh)",
    "setting-resource-requests-and-limits@8RLR6gRjIyTn6GCugEfgk": "# Setting Resource Requests and Limits\n\nResource requests and limits in Kubernetes specify the minimum and maximum amount of CPU and memory a container requires to run. Resource requests are used for scheduling containers on nodes with sufficient resources, while limits enforce resource quotas and prevent containers from consuming too much. These settings can be configured at the pod or container level using the resources field in YAML. It's important to set resource requests and limits correctly to ensure optimal resource utilization in your Kubernetes cluster.\n\nVisit the following resources to learn more:\n\n- [@official@Requests and limits - Documentation](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits)\n- [@official@Motivation for default memory limits and requests](https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/#motivation-for-default-memory-limits-and-requests)\n- [@article@Understanding Kubernetes Resource Types](https://thenewstack.io/understanding-kubernetes-resource-types/)\n- [@article@Kubernetes Requests and Limits Demystified ](https://thenewstack.io/kubernetes-requests-and-limits-demystified/)",
    "setting-up-kubernetes@3OpGaQhyNtk1n1MLp-tlb": "# Deploying your First Application\n\nTo deploy your first application in Kubernetes, you need to create a deployment and service manifest in YAML files, apply the manifests to your Kubernetes cluster using the kubectl apply command, verify that your application's pods are running with kubectl get pods, and test the service with kubectl get services and accessing the service using a web browser or a tool like cURL. There are also various tools and platforms available that can simplify application deployment in Kubernetes, such as Helm charts and Kubernetes operators.\n\nVisit the following resources to learn more:\n\n- [@official@Using kubectl to Create a Deployment](https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/)\n- [@article@Deploying An Application On Kubernetes From A to Z](https://web.archive.org/web/20230326150953/https://www.weave.works/blog/deploying-an-application-on-kubernetes-from-a-to-z)\n- [@article@Kubernetes 101: Deploy Your First Application with MicroK8s](https://thenewstack.io/kubernetes-101-deploy-your-first-application-with-microk8s/)\n- [@video@Kubernetes Tutorial | Your First Kubernetes Application](https://www.youtube.com/watch?v=Vj6EFnav5Mg)\n- [@video@Kubernetes 101: Deploying Your First Application](https://www.youtube.com/watch?v=XltFOyGanYE)",
    "should-you-manage-your-own-cluster@ZrVhYTw63aVVIFAEJDG5r": "# Own Cluster\n\nTo create your own Kubernetes cluster, you need to choose a cloud provider or set up your own infrastructure, install Kubernetes on your infrastructure, configure your cluster by setting up networking, storage, and security, deploy your applications using Kubernetes manifests, and monitor and manage your cluster using tools like Kubernetes Dashboard, kubectl, and Prometheus. This process can be complex and time-consuming, but it gives you complete control over your infrastructure and allows for customization to meet your specific needs.\n\nVisit the following resources to learn more:\n\n- [@official@Creating a cluster with kubeadm](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/)\n- [@video@KUBERNETES | Install Kubernetes Cluster](https://www.youtube.com/watch?v=Ro2qeYeisZQ)",
    "stateful-applications@LJUJ1NIUsajb1AUdvJjqW": "# Stateful Applications\n\nIn Kubernetes, storage is a key component for stateful applications, as these applications require persistent data storage that is available across multiple replicas of the application. Kubernetes provides several options for storage, including volumes, persistent volumes, and storage classes.\n\nVolumes are the basic building blocks of storage in Kubernetes. A volume is a directory that is accessible to the container running the application, and it can be backed by different types of storage, such as a host directory, a cloud provider disk, or a network storage system. Volumes are created and managed by Kubernetes, and they can be mounted into containers as part of a pod definition.\n\nVisit the following resources to learn more:\n\n- [@official@Stateful Applications](https://kubernetes.io/docs/tutorials/stateful-application/)\n- [@video@The basics of stateful applications in Kubernetes](https://www.youtube.com/watch?v=GieXzb91I40)",
    "statefulsets@AJiRBEaKU8qYEm0fqN389": "# StatefulSets\n\nIt is a controller that manages the deployment and scaling of a set of stateful pods that require stable network identities and stable storage volumes. StatefulSets are used to run stateful applications such as databases, where the order and uniqueness of each pod is important. StatefulSets provide unique stable network identities and stable storage volumes for each pod, which allows stateful applications to maintain data consistency even when they are scaled up or down, or when nodes fail or are replaced. StatefulSets are defined by a YAML file that includes a pod template, a service to access the pods, and other settings.\n\nVisit the following resources to learn more:\n\n- [@official@StatefulSets Documentation](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/)\n- [@article@Different Approaches for Building Stateful Kubernetes Applications](https://thenewstack.io/different-approaches-for-building-stateful-kubernetes-applications/)\n- [@video@Kubernetes StatefulSet | Tutorial](https://www.youtube.com/watch?v=pPQKAR1pA9U)",
    "storage-and-volumes@URnYf9jMprFz-o26fbU2P": "# CSI drivers\n\nCSI (Container Storage Interface) drivers in Kubernetes provide a standard way for storage providers to integrate with Kubernetes and offer persistent storage for containerized applications. They operate as separate containerized processes and communicate with Kubernetes through a well-defined API. CSI drivers allow Kubernetes to access a wide range of storage systems and provide advanced features like snapshotting and cloning.\n\nVisit the following resources to learn more:\n\n- [@official@Container Storage Interface (CSI) for Kubernetes](https://kubernetes.io/blog/2019/01/15/container-storage-interface-ga/)\n- [@video@CSI in Kubernetes](https://www.youtube.com/watch?v=brXPQ1Qwjl4)",
    "taints-and-tolerations@zXUsHAI1HFhcY2BFAcypv": "# Taints and Tolerations\n\nTaints and tolerations are used in Kubernetes to restrict or allow pods to be scheduled on certain nodes based on labels. A taint is a label that is applied to a node to indicate certain limitations or requirements. A toleration is a label applied to a pod to indicate that it can tolerate certain taints. When a node has a taint, only pods with the corresponding tolerations can be scheduled on that node. This feature is useful for various purposes, such as ensuring separation of critical and non-critical workloads, reserving nodes for certain tasks, and protecting nodes from overloading.\n\nVisit the following resources to learn more:\n\n- [@official@Taints and Tolerations](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/)\n- [@video@Kubernetes For Beginners: Taints & Tolerations](https://www.youtube.com/watch?v=mo2UrkjA7FE)",
    "topology-spread-constraints@CL0hKTcml40InmyVUXpY2": "# Topology Spread Constraints\n\nTopology spread constraints ensure even distribution of pods across a cluster's topology. Constraints define rules for the number of pods of a certain type that can run on a given level, such as nodes, zones, or racks. These constraints can be customized to fit specific needs, such as ensuring that critical workloads are spread across multiple zones. They help prevent single points of failure and improve application resilience by preventing resource overloading and promoting balanced distribution of workloads. Constraints can be added using the Kubernetes API or command line interface.\n\nVisit the following resources to learn more:\n\n- [@official@Topology Spread Constraints](https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/)\n- [@video@Kubernetes | Topology Spread Constraints](https://www.youtube.com/watch?v=joRrWJ6bwvE)",
    "traces@ldYTEPt_hI4PXxr3tgJi5": "# Traces\n\nTracing in Kubernetes involves monitoring the flow of requests through different components of the system, using tools such as Jaeger or Zipkin. OpenTracing and OpenCensus provide a consistent way of capturing traces across different components and applications running on the cluster. Tracing helps identify performance bottlenecks, debug issues, and optimize the system for better performance and scalability. By monitoring traces in Kubernetes, administrators can identify issues and take corrective actions to ensure efficient system performance.\n\nVisit the following resources to learn more:\n\n- [@official@Traces For Kubernetes System Components](https://kubernetes.io/docs/concepts/cluster-administration/system-traces/)\n- [@video@Introduction to Tracing](https://www.youtube.com/watch?v=idDu_jXqf4E)",
    "using-secrets-for-sensitive-data@S0CwGC2gMG-SqnLNldqBD": "# Secrets\n\nKubernetes secrets store sensitive data such as passwords, tokens, and API keys in a secure manner. They can be created manually or automatically, and stored in etcd. Secrets can be mounted as files or environment variables in a pod, and access can be managed using Kubernetes RBAC. However, they have some limitations, such as size and the inability to be updated once created. Understanding secrets is important for building secure applications in Kubernetes.\n\nVisit the following resources to learn more:\n\n- [@official@Documentation - Secrets](https://kubernetes.io/docs/concepts/configuration/secret/)\n- [@article@Kubernetes Secrets Management: 3 Approaches, 9 Best Practices](https://thenewstack.io/kubernetes-secrets-management-3-approaches-9-best-practices/)\n- [@video@Kubernetes Secrets in 5 Minutes!](https://www.youtube.com/watch?v=cQAEK9PBY8U)",
    "vertical-pod-autoscaler-vpa@c1KVczGRjh9bhMpbPP6sA": "# Vertical Pod Autoscaler\n\nVertical Pod Autoscaler (VPA) is a Kubernetes feature that automates the process of adjusting resource limits for containers in pods. Unlike Horizontal Pod Autoscaler (HPA), which scales the number of replicas of a pod, VPA scales the resources allocated to a pod's containers. It adjusts the resource requests and limits for each container based on its actual usage.\n\nVisit the following resources to learn more:\n\n- [@article@What is Kubernetes VPA?](https://www.kubecost.com/kubernetes-autoscaling/kubernetes-vpa/)\n- [@video@Vertical Pod Autoscaling: Example](https://www.youtube.com/watch?v=3h-vDDTZrm8)",
    "why-use-kubernetes@q-Ky0ietZGpyUcBQfh-BJ": "# Why Kubernetes\n\nKubernetes (k8s) is needed because it provides a powerful and flexible platform for deploying and managing containerized applications at scale. It allows for easy scalability, high resilience, application portability, automation of many tasks, and standardization of the container platform. k8s also helps reduce complexity and workload for operations teams, enabling them to focus on more strategic initiatives.\n\nVisit the following resources to learn more:\n\n- [@official@Why you need Kubernetes and what it can do](https://kubernetes.io/docs/concepts/overview/#why-you-need-kubernetes-and-what-can-it-do)\n- [@article@Primer: How Kubernetes Came to Be, What It Is, and Why You Should Care](https://thenewstack.io/primer-how-kubernetes-came-to-be-what-it-is-and-why-you-should-care/)\n- [@feed@Explore top posts about Kubernetes](https://app.daily.dev/tags/kubernetes?ref=roadmapsh)"
  },
  "kubernetes": "---\njsonUrl: '/jsons/roadmaps/kubernetes.json'\npdfUrl: '/pdfs/roadmaps/kubernetes.pdf'\norder: 14\nbriefTitle: 'Kubernetes'\nrenderer: 'editor'\nbriefDescription: 'Step by step guide to learning Kubernetes in 2025'\ntitle: 'Kubernetes Roadmap'\ndescription: 'Step by step guide to learning Kubernetes in 2025'\nisNew: false\nhasTopics: true\npartner:\n  description: 'Get the latest Kubernetes news from our sister site'\n  link: 'https://thenewstack.io/?utm_source=roadmap.sh&utm_medium=Referral&utm_campaign=Alert'\n  linkText: 'TheNewStack.io'\ndimensions:\n  width: 968\n  height: 1950\nschema:\n  headline: 'Kubernetes Roadmap'\n  description: 'Learn how to use Kubernetes with this interactive step by step guide in 2025. We also have resources and short descriptions attached to the roadmap items so you can get everything you want to learn in one place.'\n  imageUrl: 'https://roadmap.sh/roadmaps/kubernetes.png'\n  datePublished: '2023-05-04'\n  dateModified: '2023-05-04'\nseo:\n  title: 'Kubernetes Roadmap'\n  description: 'Step by step guide to learn Kubernetes in 2025. We also have resources and short descriptions attached to the roadmap items so you can get everything you want to learn in one place.'\n  keywords:\n    - 'kubernetes tutorial'\n    - 'step by step kubernetes'\n    - 'kubernetes roadmap 2024'\n    - 'kubernetes roadmap 2025'\n    - 'guide to learning kubernetes'\n    - 'kubernetes'\n    - 'kubernetes engineer'\n    - 'kubernetes engineer 2025'\n    - 'kubernetes skills'\n    - 'kubernetes development'\n    - 'kubernetes development skills'\n    - 'kubernetes development skills test'\n    - 'kubernetes engineer roadmap'\n    - 'kubernetes roadmap'\n    - 'become a kubernetes expert'\n    - 'kubernetes career path'\n    - 'learn kubernetes development'\n    - 'what is kubernetes'\n    - 'kubernetes quiz'\n    - 'kubernetes interview questions'\nrelatedRoadmaps:\n  - 'docker'\n  - 'devops'\n  - 'cloudflare'\n  - 'backend'\nsitemap:\n  priority: 1\n  changefreq: 'monthly'\ntags:\n  - 'roadmap'\n  - 'main-sitemap'\n  - 'skill-roadmap'\n---\n",
  "migration-mapping": {
    "kubernetes-introduction": "y7KjVfSI6CAduyHd4mBFT",
    "containers": "HGmeYvRf7_XusZl_K4x9k",
    "setting-up-kubernetes": "3OpGaQhyNtk1n1MLp-tlb",
    "kubernetes-introduction:kubernetes-overview": "qLeEEwBvlGt1fP5Qcreah",
    "kubernetes-introduction:why-kubernetes": "q-Ky0ietZGpyUcBQfh-BJ",
    "kubernetes-introduction:key-concepts-terminologies": "9oo2fxTM2_p0VYPBroqxa",
    "kubernetes-introduction:kubernetes-alternatives": "3fzuXKH7az_LVnmnoXB1p",
    "setting-up-kubernetes:deploying-your-first-application": "zrbSJa3k7a3TE0aYbWi9c",
    "setting-up-kubernetes:choosing-a-managed-provider": "qSatCdBTDXPu-IFWzUI99",
    "setting-up-kubernetes:installing-a-local-cluster": "YaIs8lquWIe1D7RCUBZmC",
    "running-applications": "1MdrzhktCWjpmxiYYBdz7",
    "running-applications:pods": "-d2PIXm0V_Iehe8cws8zK",
    "running-applications:replicasets": "IF09l0-pryGpMbDt__ocr",
    "running-applications:deployments": "TUGQX7y1gs-aKPge2F1NU",
    "running-applications:statefulsets": "AJiRBEaKU8qYEm0fqN389",
    "running-applications:jobs": "r3fzAN5DzratAKnnT8hzb",
    "services-and-networking": "aUJ_w2L8nxNq3DfAW97Gd",
    "services-and-networking:external-access-to-services": "jUOlITLqnIvSu97I_3nBz",
    "services-and-networking:load-balancing": "Qelo1YvAcUoX5PA-RYbNp",
    "services-and-networking:networking-and-pod-to-pod-communication": "44rhdieUCWsGFC_1__9kk",
    "configuration-management": "dj7Tb2XTX4kxRUYiTjlhM",
    "configuration-management:config-maps": "u24UlZKI86vaguj_VpMv1",
    "configuration-management:secrets": "S0CwGC2gMG-SqnLNldqBD",
    "resource-management": "eWKkdiBhD5x2sGYajmHEs",
    "resource-management:setting-resource-requests-and-limits": "8RLR6gRjIyTn6GCugEfgk",
    "resource-management:assigning-quotas-to-namespaces": "OHz4QMmA3lqL_C7aWL8Ga",
    "resource-management:monitoring-and-optimizing-resource-usage": "PP4ld_vvjpY3QltBBsXKD",
    "kubernetes-security": "SG3wtV2rt9nmLEkgrp_zP",
    "kubernetes-security:role-based-acccess-control": "jOq0WwLrq8tlmOgo64QDc",
    "kubernetes-security:network-security": "s0gHg8CqwrSylpSPu8arA",
    "kubernetes-security:container-and-pod-security": "Nja7IFWcFTLsPcqbvRNm9",
    "kubernetes-security:security-scanners": "i7qxaFhFHPfe3fGEgsbcE",
    "monitoring-and-logging": "AgsQnQjyTLUFhFpRdcE13",
    "monitoring-and-logging:logs": "-XxQtiLDAkXs7IFM_Ddw6",
    "monitoring-and-logging:metrics": "nqUBHBFUYFdYqCKZvfXBR",
    "monitoring-and-logging:traces": "ldYTEPt_hI4PXxr3tgJi5",
    "monitoring-and-logging:resource-health": "pDjNsK5vI9FmKZbQm0lDP",
    "monitoring-and-logging:observability-engines": "FANswgUhUb5Iuah2fni3L",
    "autoscaling": "03mGA5AyL7mpF6y3EMW7A",
    "autoscaling:horizontal-pod-autoscaler": "044IUUCgZP4oQ9UxUG2iy",
    "autoscaling:vertical-pod-autoscaler": "c1KVczGRjh9bhMpbPP6sA",
    "autoscaling:cluster-autoscaling": "RC5MoYtG2rom-d4FW5qD2",
    "scheduling": "xZDXM_8qb4VL15tNGG0ws",
    "scheduling:scheduling-basics": "70lTSIVh0AD6M8fMMuWzY",
    "scheduling:taints-and-tolerations": "zXUsHAI1HFhcY2BFAcypv",
    "scheduling:topology-spread-constraints": "CL0hKTcml40InmyVUXpY2",
    "scheduling:pod-priorities": "_Gva1eGcYqpmZNPyV03lt",
    "scheduling:evictions": "TRKzlDW2PQN9bWTyz3NWL",
    "storage-and-volumes": "URnYf9jMprFz-o26fbU2P",
    "storage-and-volumes:csi-drivers": "55RV9psPCmcg8G_P_zQo9",
    "storage-and-volumes:stateful-applications": "LJUJ1NIUsajb1AUdvJjqW",
    "deployment-patterns": "0l0xpsabglvs_t6oAP-XG",
    "deployment-patterns:ci-cd-integration": "Pymc9H-lRHVPy7M9eSaPD",
    "deployment-patterns:gitops": "dATdEyNWlpDNKjedCXLyb",
    "deployment-patterns:helm-charts": "FAEFOhLdp7xrmctHFxiOM",
    "deployment-patterns:canary-deployments": "88IGeC3dAopHLGtLozxdY",
    "deployment-patterns:blue-green-deployments": "9-oaTlzKmcxTfaRycz1w3",
    "deployment-patterns:rolling-updates-rollbacks": "yMSXdwDO36CLtp2TBC7aB",
    "kubernetes-advanced-topics:custom-controllers": "L9rVPEEXFwisQOwT_LQ4v",
    "kubernetes-advanced-topics:custom-schedulers-extenders": "1-Nb8rCMJEZrYm20sEcRJ",
    "kubernetes-advanced-topics:custom-resource-definitions": "9P7l-RBOkUxs3Z_UpKQO-",
    "kubernetes-advanced-topics:kubernetes-extensions-and-apis": "UeJcKv3jhenjNzHM-0R86",
    "kubernetes-advanced-topics:own-cluster": "ZrVhYTw63aVVIFAEJDG5r",
    "kubernetes-advanced-topics:control-plane-installation": "M-iTb_7EWZIJ3JpdViICx",
    "kubernetes-advanced-topics:managing-worker-nodes": "2cQKTxln3dIk5IjX2UZdM",
    "kubernetes-advanced-topics:multi-cluster-management": "auZgEQ6FC3nUjuyx0zANh"
  }
}