{
  "content": {
    "application-architecture@EqYWfBL5l5OOquok_OvOW": "# Application Architecture\n\nApplication architecture in containerized environments focuses on designing applications to leverage containerization benefits. This includes microservices patterns, service decomposition, inter-service communication, data persistence strategies, and designing for scalability and fault tolerance in distributed systems.\n\nVisit the following resources to learn more:\n\n- [@article@Microservices Architecture](https://microservices.io/)\n- [@official@Docker Application Design Patterns](https://docs.docker.com/get-started/docker-concepts/building-images/)\n- [@article@Container Design Patterns](https://kubernetes.io/blog/2016/06/container-design-patterns/)\n- [@article@Twelve-Factor App Methodology](https://12factor.net/)\n- [@video@Microservices vs Monolith Architecture](https://www.youtube.com/watch?v=GBTdnfD6s5Q)",
    "bare-metal-vs-vms-vs-containers@3hatcMVLDbMuz73uTx-9P": "# Bare Metal vs VM vs Containers\n\nBare metal runs applications directly on hardware with maximum performance but limited flexibility. VMs use hypervisors to run multiple OS instances with strong isolation but higher overhead. Containers share the host OS kernel, providing lightweight isolation with better resource efficiency than VMs while maintaining portability.\n\nYou can learn more from the following resources:\n\n- [@article@History of Virtualization](https://courses.devopsdirective.com/docker-beginner-to-pro/lessons/01-history-and-motivation/03-history-of-virtualization)\n- [@article@Bare Metal Machine](https://glossary.cncf.io/bare-metal-machine/)\n- [@article@What is a Virtual Machine?](https://azure.microsoft.com/en-au/resources/cloud-computing-dictionary/what-is-a-virtual-machine) ",
    "basics-of-docker@kIqx7Inf50mE9W0juwNBz": "# Docker Basics\n\nDocker is a platform that simplifies building, packaging, and deploying applications in lightweight, portable containers. Key components include Dockerfiles (build instructions), Images (snapshots), and Containers (running instances). Essential commands cover pulling images, building from Dockerfiles, running containers with port mapping, and managing both containers and images.\n\n## What is a Container?\n\nA container is a lightweight, standalone, and executable software package that includes all the dependencies (libraries, binaries, and configuration files) required to run an application. Containers isolate applications from their environment, ensuring they work consistently across different systems.\n\n## Docker Components\n\nThere are three key components in the Docker ecosystem:\n\n- **Dockerfile**: A text file containing instructions (commands) to build a Docker image.\n- **Docker Image**: A snapshot of a container, created from a Dockerfile. Images are stored in a registry, like Docker Hub, and can be pulled or pushed to the registry.\n- **Docker Container**: A running instance of a Docker image.\n\n## Docker Commands\n\nBelow are some essential Docker commands you'll use frequently:\n\n- `docker pull <image>`: Download an image from a registry, like Docker Hub.\n- `docker build -t <image_name> <path>`: Build an image from a Dockerfile, where `<path>` is the directory containing the Dockerfile.\n- `docker image ls`: List all images available on your local machine.\n- `docker run -d -p <host_port>:<container_port> --name <container_name> <image>`: Run a container from an image, mapping host ports to container ports.\n- `docker container ls`: List all running containers.\n- `docker container stop <container>`: Stop a running container.\n- `docker container rm <container>`: Remove a stopped container.\n- `docker image rm <image>`: Remove an image from your local machine.\n",
    "bind-mounts@wZcCW1ojGzUakHCv2AaI1": "# Bind Mounts\n\nBind mounts have limited functionality compared to volumes. When you use a bind mount, a file or directory on the host machine is mounted into a container. The file or directory is referenced by its absolute path on the host machine. By contrast, when you use a volume, a new directory is created within Docker's storage directory on the host machine, and Docker manages that directory's contents.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Bind Mounts](https://docs.docker.com/storage/bind-mounts/)\n",
    "building-container-images@5OEfBQaYNOCi999x6QUqW": "# Building Container Images\n\nContainer images are executable packages that include everything required to run an application: code, runtime, system tools, libraries, and settings. By building custom images, you can deploy applications seamlessly with all their dependencies on any Docker-supported platform. The key component in building a container image is the `Dockerfile`. It is essentially a script containing instructions on how to assemble a Docker image. Each instruction in the Dockerfile creates a new layer in the image, making it easier to track changes and minimize the image size. Here's a simple example of a Dockerfile:\n\nVisit the following resources to learn more:\n\n- [@official@Docker Image Builder](https://docs.docker.com/reference/cli/docker/buildx/build/)\n- [@official@Dockerfile Reference](https://docs.docker.com/engine/reference/builder/)\n- [@opensource@Dockerfile Examples](https://github.com/dockersamples)\n",
    "cgroups@fRl4EfNwlBiidzn3IV34-": "# cgroups\n\ncgroups (control groups) are Linux kernel features that limit and manage system resources like CPU, memory, and I/O for process groups. Docker uses cgroups to enforce resource constraints on containers, ensuring predictable performance and preventing containers from consuming excessive system resources.\n\nVisit the following resources to learn more:\n\n- [@official@Control Groups](https://www.docker.com/resources/what-container/#control-groups)\n- [@article@Control Groups - Medium](https://medium.com/@furkan.turkal/how-does-docker-actually-work-the-hard-way-a-technical-deep-diving-c5b8ea2f0422)\n- [@video@An introduction to cgroups, runc & containerD](https://www.youtube.com/watch?v=u1LeMndEk70) ",
    "command-line-utilities@YzpB7rgSR4ueQRLa0bRWa": "# Command Line Utilities\n\nDocker images can include command line utilities or standalone applications that we can run inside containers.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Images](https://docs.docker.com/engine/reference/commandline/images/)\n- [@official@Docker Run](https://docs.docker.com/reference/cli/docker/container/run/)\n- [@official@Docker Pull](https://docs.docker.com/engine/reference/commandline/pull/)\n",
    "container-registries@3VKPiMfbGBxv9m_SljIQV": "# Container Registries\n\nA Container Registry is a centralized storage and distribution system for Docker container images. It allows developers to easily share and deploy applications in the form of these images. Container registries play a crucial role in the deployment of containerized applications, as they provide a fast, reliable, and secure way to distribute container images across various production environments.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Registry](https://docs.docker.com/registry/)\n- [@official@Docker Hub](https://hub.docker.com/)\n- [@official@Artifact Registry](https://cloud.google.com/artifact-registry)\n- [@official@Amazon ECR](https://aws.amazon.com/ecr/)\n- [@official@Azure Container Registry](https://azure.microsoft.com/en-in/products/container-registry)\n",
    "container-security@78YFahP3Fg-c27reLkuK4": "# Container Security\n\nContainer security encompasses a broad set of practices and tools aimed at protecting containerized applications from development through deployment and runtime. It involves securing the container image, ensuring that only trusted and non-vulnerable code is used, implementing strong access controls for container environments, and configuring containers to follow the principle of least privilege. Additionally, it includes monitoring for unexpected behavior, protecting communication between containers, and maintaining the host environment’s security. Effective container security integrates seamlessly into DevSecOps workflows to provide continuous visibility and protection across the container lifecycle without disrupting development speed or agility.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Security](https://docs.docker.com/engine/security/)\n- [@article@Kubernetes Security Best Practices](https://www.aquasec.com/cloud-native-academy/kubernetes-in-production/kubernetes-security-best-practices-10-steps-to-securing-k8s/)\n",
    "containers@jhwe-xfVc-C7qy8YuS5dZ": "# Containers\n\nContainers are isolated, lightweight environments that run applications using a shared operating system kernel, ensuring consistency and portability across different computing environments. They encapsulate everything needed to run an application, such as code, dependencies, and configurations, making it easy to move and run the containerized application anywhere. Using the Docker CLI, you can create, start, stop, and manage containers with commands like `docker run`, `docker ps` to list running containers, `docker stop` to halt them, and `docker exec` to interact with them in real time. The CLI provides a powerful interface for developers to build, control, and debug containers effortlessly, allowing for streamlined development and operational workflows.\n\nVisit the following resources to learn more:\n\n- [@official@Docker CLI Commands](https://docs.docker.com/engine/reference/commandline/cli/)\n- [@article@Docker CLI Commands Cheat Sheet](https://docs.docker.com/get-started/docker_cheatsheet.pdf)\n",
    "continuous-integration@oyqw4tr-taZcxt5kREh1g": "# Continuous Integration (CI)\n\nContinuous integration is the idea of executing some actions (for example build, test, etc...) automatically as you push code to your version control system.\n\nFor containers, there are a number of things we may want to do:\n\n- Build the container images\n- Execute tests\n- Scan container images for vulnerabilities\n- Tag images with useful metadata\n- Push to a container registry\n\nVisit the following resources to learn more:\n\n- [@article@Continuous Integration - Docker](https://courses.devopsdirective.com/docker-beginner-to-pro/lessons/11-development-workflow/04-continuous-integration-github-actions)\n- [@feed@Explore top posts about CI/CD](https://app.daily.dev/tags/cicd?ref=roadmapsh)\n",
    "data-persistence@uUPYXmwu27SBPqKZx6U_q": "# Data Persistence in Docker\n\nDocker enables you to run containers that are isolated pieces of code, including applications and their dependencies, separated from the host operating system. Containers are ephemeral by default, which means any data stored in the container will be lost once it is terminated. To overcome this problem and retain data across container lifecycle, Docker provides various data persistence methods.\n\nVisit the following resources to learn more:\n\n- [@official@Data Persistence - Docker Documentation](https://docs.docker.com/get-started/docker-concepts/running-containers/persisting-container-data/)\n",
    "databases@jKSE_wKYf4P9wnSh_LkMi": "# Using Databases\n\nRunning your database in a Docker container can help streamline your development process and ease deployment. Docker Hub provides numerous pre-made images for popular databases such as MySQL, PostgreSQL, and MongoDB.\n\nVisit the following resources to learn more:\n\n- [@official@Containerized Databases](https://docs.docker.com/guides/use-case/databases/)\n- [@video@How to Setup MySQL Database with Docker](https://www.youtube.com/watch?v=igc2zsOKPJs)\n",
    "debuggers@LiAV9crrTHhLqeZhD25a2": "# Debuggers in Docker\n\nIn order to make developing with containers competitive with developing locally, we need the ability to run and attach to debuggers inside the container.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Buildx Debug](https://docs.docker.com/reference/cli/docker/buildx/debug/)\n- [@article@Debuggers in Docker](https://courses.devopsdirective.com/docker-beginner-to-pro/lessons/11-development-workflow/02-debug-and-test)\n",
    "deploying-containers@qXOGqORi3EdqwsP9Uhi9m": "# Deploying Containers\n\nDeploying containers is a crucial step in using Docker and containerization to manage applications more efficiently, easily scale, and ensure consistent performance across environments. This topic will give you an overview of how to deploy Docker containers to create and run your applications.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Deployment](https://docs.docker.com/get-started/deployment/)\n- [@official@Docker Compose](https://docs.docker.com/compose/)\n- [@official@Docker Swarm](https://docs.docker.com/engine/swarm/)\n",
    "developer-experience@hHXTth0ZP8O-iMGR9xfu9": "# Developer Experience\n\nDocker significantly enhances the developer experience by providing a consistent, isolated environment for building, testing, and running applications, eliminating the “it works on my machine” problem. With Docker, developers can package their applications and dependencies into portable containers, ensuring consistency across different environments, from local development to staging and production. The simplified setup and reproducibility of environments accelerate onboarding, minimize conflicts, and allow developers to focus on coding rather than troubleshooting configurations. Moreover, tools like Docker Compose enable quick orchestration of complex multi-container applications, making it easier to prototype, iterate, and collaborate, ultimately streamlining the entire development lifecycle.\n\nFor more details and practical examples:\n\n- [@article@Developer Experience Wishlist - Docker](https://courses.devopsdirective.com/docker-beginner-to-pro/lessons/11-development-workflow/00-devx-wishlist#key-devx-features)\n- [@official@Docker Developer Experience](https://www.docker.com/blog/cto-chat-overcoming-the-developer-experience-gap-feat-redmonk-flow-io/)\n",
    "docker-and-oci@43drPbTwPqJQPyzwYUdBT": "# Docker and OCI\n\nThe Open Container Initiative (OCI) is a Linux Foundation project which aims at creating industry standards for container formats and runtimes. Its primary goal is to ensure the compatibility and interoperability of container environments through defined technical specifications.\n\nYou can learn more from the following resources:\n\n- [@official@Open Container Initiative](https://opencontainers.org/)\n- [@article@OCI - Wikipedia](https://en.wikipedia.org/wiki/Open_Container_Initiative)\n",
    "docker-cli@b-LwyYiegbF0jIrn7HYRv": "# Docker CLI\n\nThe Docker Command Line Interface (CLI) is a powerful tool used to interact with the Docker engine, enabling developers and operators to build, manage, and troubleshoot containers and related resources. With a wide range of commands, the Docker CLI provides control over all aspects of Docker, including creating and managing containers (`docker run`, `docker stop`), building images (`docker build`), managing networks (`docker network`), handling storage (`docker volume`), and inspecting system status (`docker ps`, `docker info`). Its intuitive syntax and flexibility allow users to automate complex workflows, streamline development processes, and maintain containerized applications with ease, making it a foundational utility for Docker management and orchestration.\n\nVisit the following resources to learn more:\n\n- [@official@Docker CLI](https://docs.docker.com/reference/cli/docker/)\n- [@official@Docker Compose](https://docs.docker.com/compose/)\n",
    "docker-compose@jjA9E0J8N2frfeJCNtA1m": "# Docker Compose\n\nDocker Compose is a tool for defining and running multi-container applications using a YAML file (`docker-compose.yml`). It describes application services, networks, and volumes, enabling you to create, manage, and run entire containerized applications with single commands for simplified orchestration.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Compose documentation](https://docs.docker.com/compose/)\n- [@video@Docker Compose Tutorial](https://www.youtube.com/watch?v=DM65_JyGxCo)\n- [@opensource@Curated Docker Compose Samples](https://github.com/docker/awesome-compose?tab=readme-ov-file)\n",
    "docker-desktop-winmaclinux@NCdsPRhJy7UtQFNLo1J1f": "# Docker Desktop\n\nDocker Desktop is a comprehensive development environment for Windows, macOS, and Linux with a GUI. It includes Docker Engine, CLI, Buildx, Extensions, Compose, Kubernetes, and credentials helper, providing everything needed for container development on desktop platforms.\n\nLearn more from the following resources:\n\n- [@official@Docker Desktop Documentation](https://docs.docker.com/desktop/)\n- [@official@Docker Get Started Guide](https://docs.docker.com/get-started/)\n- [@official@Docker Hub](https://hub.docker.com/)\n- [@feed@Explore top posts about Docker](https://app.daily.dev/tags/docker?ref=roadmapsh)\n",
    "docker-engine--linux@0NKqLUWtJMlXn-m6wpA6f": "# Docker Engine\n\nDocker Engine is the core open-source containerization runtime that creates and manages containers, builds images, and provides the Docker API. It runs on Linux, Windows, and macOS, serving as the foundation for Docker Desktop and standalone Docker installations on servers.\n\nFor more information about docker engine see:\n\n- [@official@Docker Engine Installation Guide](https://docs.docker.com/engine/install/)\n- [@official@Docker Engine - Docker Documentation](https://docs.docker.com/engine/)\n- [@video@Docker Engine for Linux Servers Setup and Tips](https://www.youtube.com/watch?v=YeF7ObTnDwc)\n- [@feed@Explore top posts about Docker](https://app.daily.dev/tags/docker?ref=roadmapsh)\n",
    "docker-run@6eu5NRA1sJuaHTlHtNurc": "# Running Containers\n\nThe `docker run` command creates and starts a new container from a specified image. It combines `docker create` and `docker start` operations, offering a range of options to customize the container's runtime environment. Users can set environment variables, map ports and volumes, define network connections, and specify resource limits. The command supports detached mode for background execution, interactive mode for shell access, and the ability to override the default command defined in the image. Common flags include `-d` for detached mode, `-p` for port mapping, `-v` for volume mounting, and `--name` for assigning a custom container name. Understanding `docker run` is fundamental to effectively deploying and managing Docker containers.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Run](https://docs.docker.com/engine/reference/commandline/run/)\n",
    "docker-swarm@ks6PFN-0Z9zH7gtWaWgxz": "# Docker Swarm\n\nDocker Swarm is Docker’s native container orchestration tool that allows users to deploy, manage, and scale containers across a cluster of Docker hosts. By transforming a group of Docker nodes into a single, unified cluster, Swarm provides high availability, load balancing, and automated container scheduling using simple declarative commands. With features like service discovery, rolling updates, and integrated security through TLS encryption, Docker Swarm offers an approachable alternative to more complex orchestrators like Kubernetes. Its tight integration with the Docker CLI and ease of setup make it a suitable choice for small to medium-sized deployments where simplicity and straightforward management are priorities.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Swarm](https://docs.docker.com/engine/swarm/)\n",
    "dockerfiles@yGRQcx64S-yBGEoOeMc55": "# Dockerfile\n\nA Dockerfile is a text document that contains a list of instructions used by the Docker engine to build an image. Each instruction in the Dockerfile adds a new layer to the image. Docker will build the image based on these instructions, and then you can run containers from the image.\n\nVisit the following resources to learn more:\n\n- [@official@Dockerfile Reference](https://docs.docker.com/engine/reference/builder/)\n- [@official@Dockerfile Best Practices](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)\n- [@opensource@Dockerfile Examples](https://github.com/dockersamples)\n",
    "dockerhub@rxVR62_yXIjc-L4GFSV6u": "# DockerHub\n\nDocker Hub is a cloud-based registry service that serves as the primary public repository for Docker container images. It allows users to store, share, and distribute Docker images, offering both free public repositories and paid private ones and integrates seamlessly with Docker CLI, enabling easy pushing and pulling of images. It features official images maintained by software vendors, automated builds linked to source code repositories, and webhooks for triggering actions based on repository events.\n\nVisit the following resources to learn more:\n\n- [@official@DockerHub](https://hub.docker.com/)\n- [@official@DockerHub Repositories](https://docs.docker.com/docker-hub/repos/)\n- [@official@DockerHub Webhooks](https://docs.docker.com/docker-hub/webhooks/)\n",
    "efficient-layer-caching@frshJqVMP8D7o_7tMZMPI": "# Efficient Layer Caching\n\nWhen building container images, Docker caches the newly created layers. These layers can then be used later on when building other images, reducing the build time and minimizing bandwidth usage. However, to make the most of this caching mechanism, you should be aware of how to efficiently use layer caching. Docker creates a new layer for each instruction (e.g., `RUN`, `COPY`, `ADD`, etc.) in the Dockerfile. If the instruction hasn't changed since the last build, Docker will reuse the existing layer.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Layer Caching](https://docs.docker.com/build/cache/)\n- [@video@Layer Caching](https://www.youtube.com/watch?v=_nMpndIyaBU)\n",
    "ephemeral-container-filesystem@086zZYjtzdCaDHm-MkSqg": "# Ephemeral FS\n\nBy default, the storage within a Docker container is ephemeral, meaning that any data changes or modifications made inside a container will only persist until the container is stopped and removed. Once the container is stopped and removed, all the associated data will be lost. This is because Docker containers are designed to be stateless by nature. This temporary or short-lived storage is called the \"ephemeral container file system\". It is an essential feature of Docker, as it enables fast and consistent deployment of applications across different environments without worrying about the state of a container.\n\nVisit the following resources to learn more:\n\n- [@official@Data Persistence - Docker Documentation](https://docs.docker.com/get-started/docker-concepts/running-containers/persisting-container-data/)\n- [@video@Docker Concepts - Persisting container data](https://www.youtube.com/watch?v=10_2BjqB_Ls)\n",
    "hot-reloading@4p5d3rzCHy4vjg2PRX-2k": "# Hot Reloading in Docker\n\nEven though we can speed up the image building with layer caching enable, we don't want to have to rebuild our container image with every code change. Instead, we want the state of our application in the container to reflect changes immediately. We can achieve this through a combination of bind mounts and hot reloading utilities!\n\nHave a look at the following resources for sample implementations:\n\n- [@article@Hot Reloading - Docker](https://courses.devopsdirective.com/docker-beginner-to-pro/lessons/11-development-workflow/01-hot-reloading)\n",
    "image-security@M5UG-ZcyhBPbksZd0ZdNt": "# Image Security\n\nImage security is a crucial aspect of deploying Docker containers in your environment. Ensuring the images you use are secure, up to date, and free of vulnerabilities is essential. In this section, we will review best practices and tools for securing and managing your Docker images. When pulling images from public repositories, always use trusted, official images as a starting point for your containerized applications. Official images are vetted by Docker and are regularly updated with security fixes. You can find these images on the Docker Hub or other trusted registries.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Content Trust](https://docs.docker.com/engine/security/trust/content_trust/)\n- [@official@Docker Hub](https://hub.docker.com/)\n",
    "image-size-and-security@-8wAzF6_3gruiM3VYMvB0": "# Reducing Image Size\n\nReducing Docker image size is crucial for optimizing storage, transfer speeds, and deployment times. Key strategies include using minimal base images like Alpine Linux, leveraging multi-stage builds to exclude unnecessary build tools, removing unnecessary files and packages, and minimizing the number of layers by combining commands. \n\nVisit the following resources to learn more:\n\n- [@official@Multi-stage builds](https://docs.docker.com/build/building/multi-stage/)\n- [@official@Docker Best Practices](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)\n- [@feed@Explore top posts about Security](https://app.daily.dev/tags/security?ref=roadmapsh)\n",
    "image-tagging-best-practices@Vs4WQwgJFhA63U9Gf2ym0": "# Image Tagging Best Practices\n\nDocker image tagging best practices center on creating clear, consistent, and informative labels. Adopt semantic versioning for releases, avoid the ambiguous \"latest\" tag in production, and include relevant metadata like build dates or Git commit hashes. Implement a strategy distinguishing between environments, use descriptive tags for variants, and automate tagging in CI/CD pipelines. Regularly clean up old tags and document your conventions to maintain clarity and facilitate team-wide adoption. These practices ensure efficient image management and improve collaboration across your organization.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Tags](https://docs.docker.com/get-started/docker-concepts/building-images/build-tag-and-publish-an-image/)\n- [@article@Docker Image Tagging Best Practices](https://medium.com/@nirmalkushwah08/docker-image-tagging-strategy-4aa886fb4fcc)\n- [@article@Semantic Versioning](https://semver.org/)\n",
    "images@3Nsg-F3wMKEzEsXw1MBZv": "# Docker Images\n\nDocker images are lightweight, standalone packages containing everything needed to run software: application code, runtime, libraries, and system tools. Built in layers for efficient storage, they serve as blueprints for containers and can be shared through registries like Docker Hub for consistent deployment across environments.\n\nLearn more from the following resources:\n\n- [@article@What's the Difference Between Docker Images and Containers?](https://aws.amazon.com/compare/the-difference-between-docker-images-and-containers/)\n- [@video@What is an image?](https://www.youtube.com/watch?v=NyvT9REqLe4)\n",
    "installation--setup@01nDXqxVdMv4SeXc0nYHH": "# Installation Setup\n\nDocker provides Docker Desktop, a desktop application that simplifies installation and setup with GUI capabilities. Alternatively, you can install Docker Engine for command-line only functionality without graphical interface components.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Desktop website](https://www.docker.com/products/docker-desktop)\n- [@official@Docker Engine](https://docs.docker.com/engine/install/)\n",
    "interactive-test-environments@HlTxLqKNFMhghtKF6AcWu": "# Interactive Test Environments with Docker\n\nDocker allows you to create isolated, disposable environments that can be deleted once you're done with testing. This makes it much easier to work with third party software, test different dependencies or versions, and quickly experiment without the risk of damaging your local setup.\n\nVisit the following resources to learn more:\n\n- [@official@Launch a Dev Environment](https://docs.docker.com/desktop/dev-environments/create-dev-env/)\n- [@article@Test Environments - Medium](https://manishsaini74.medium.com/containerized-testing-orchestrating-test-environments-with-docker-5201bfadfdf2)\n",
    "introduction@Py9nst2FDJ1_hoXeX_qSF": "# What is Docker?\n\nDocker is an open-source platform that automates application deployment, scaling, and management using lightweight, portable containers. Containers are standalone executable units containing all necessary dependencies, libraries, and configuration files for consistent application execution across various environments.\n\nVisit the following resources to learn more:\n\n- [@official@Docker](https://www.docker.com/)\n- [@official@Docker Docs](https://docs.docker.com/)\n",
    "kubernetes@RqXpX2XabtHYVjgg1EZR_": "# Kubernetes\n\nKubernetes is an open-source container orchestration platform designed to automate the deployment, scaling, and management of containerized applications. It provides a robust framework for handling complex container workloads by organizing containers into logical units called pods, managing service discovery, load balancing, and scaling through declarative configurations. Kubernetes enables teams to deploy containers across clusters of machines, ensuring high availability and fault tolerance through self-healing capabilities like automatic restarts, replacements, and rollback mechanisms. With its extensive ecosystem and flexibility, Kubernetes has become the de facto standard for running large-scale, distributed applications, simplifying operations and improving the reliability of containerized workloads.\n\nVisit the following resources to learn more:\n\n- [@official@Kubernetes](https://kubernetes.io/)\n- [@official@Docker Swarm](https://docs.docker.com/engine/swarm/)\n",
    "namespaces@BvV8VCX39wRB-g8WvGF1g": "# What are Namespaces?\n\nDocker namespaces are a Linux kernel feature that creates isolated environments for containers by providing separate instances of global system resources. Docker uses PID, NET, MNT, UTS, IPC, and USER namespaces to ensure each container believes it has its own unique resources, enabling lightweight, portable, and secure containerization.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Namespaces](https://docs.docker.com/engine/security/userns-remap/)\n- [@article@Linux Namespaces](https://man7.org/linux/man-pages/man7/namespaces.7.html)\n",
    "networks@w5QjzvOaciK2rotOkjvjQ": "# Docker Networks\n\nDocker networks enable containers to communicate with each other and with external systems, providing the necessary connectivity for microservices architectures. By default, Docker offers several network types such as bridge, host, and overlay, each suited for different use cases like isolated environments, high-performance scenarios, or multi-host communication. Using the Docker CLI, you can create, inspect, and manage networks with commands like `docker network create` to define custom networks, `docker network ls` to list existing networks, and `docker network connect` to attach a container to a network. This flexibility allows developers to control how containers interact, ensuring secure and efficient communication across distributed applications.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Networks](https://docs.docker.com/network/)\n- [@official@Docker Network Commands](https://docs.docker.com/engine/reference/commandline/network/)\n- [@video@Docker Networking](https://www.youtube.com/watch?v=bKFMS5C4CG0)\n",
    "nomad@r1eJZDZYouUjnGwAtRbyU": "# Nomad: Deploying Containers\n\nNomad is a cluster manager and scheduler that enables you to deploy, manage and scale your containerized applications. It automatically handles node failures, resource allocation, and container orchestration. Nomad supports running Docker containers as well as other container runtime(s) and non-containerized applications.\n\nVisit the following resources to learn more:\n\n- [@official@Nomad Documentation](https://www.nomadproject.io/docs)\n",
    "others-ghcr-ecr-gcr-acr-etc@fh5aERX7c-lY9FPsmftoF": "# DockerHub Alternatives\n\nContainer images can be stored in many different registries, not just Dockerhub. Most major cloud platforms now provide container registries such as \"Artifact Registry\" on Google Cloud Platform, Elastic Container Registry on AWS and Azure Container Registry on Microsoft Azure. GitHub also provides it's own registry which is useful when container builds are included in your GitHub Actions workflow.\n\nVisit the following resources to learn more:\n\n- [@official@DockerHub](https://hub.docker.com/)\n- [@official@Artifact Registry](https://cloud.google.com/artifact-registry)\n- [@official@Amazon ECR](https://aws.amazon.com/ecr/)\n- [@official@Azure Container Registry](https://azure.microsoft.com/en-in/products/container-registry)\n- [@official@GitHub Container Registry](https://docs.github.com/en/packages/guides/about-github-container-registry)\n",
    "paas-options@PP_RRBo_pThe2mgf6xzMP": "# PaaS Options for Deploying Containers\n\nPlatform-as-a-Service (PaaS) options for deploying containers provide a simplified and managed environment where developers can build, deploy, and scale containerized applications without worrying about the underlying infrastructure. Popular PaaS offerings include Google Cloud Run, Azure App Service, AWS Elastic Beanstalk, and Heroku, which abstract away container orchestration complexities while offering automated scaling, easy integration with CI/CD pipelines, and monitoring capabilities. These platforms support rapid development and deployment by allowing teams to focus on application logic rather than server management, providing a seamless way to run containers in production with minimal operational overhead.\n\nVisit the following resources to learn more:\n\n- [@official@PaaS Options for Deploying Containers](https://www.docker.com/resources/what-container/#paas-options)\n- [@official@Azure Container Instances](https://azure.microsoft.com/en-us/services/container-instances/)\n- [@official@Google Cloud Run](https://cloud.google.com/run)\n- [@official@IBM Cloud Code Engine](https://www.ibm.com/cloud/code-engine)\n- [@official@Amazon Elastic Container Service](https://aws.amazon.com/ecs/)\n",
    "package-managers@mw-weCutd2ECKlx2DE_ZJ": "# Package Managers",
    "programming-languages@XxT9UUjbKW1ARyERSLH_W": "# Programming Languages",
    "running-containers@z2eeBXPzo-diQ67Fcfyhc": "# Running Containers\n\nThe `docker run` command creates and starts containers from images in one step. It combines `docker create` and `docker start` operations, allowing you to execute applications in isolated environments with various configuration options like port mapping, volumes, and environment variables.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Run](https://docs.docker.com/engine/reference/commandline/run/)\n- [@official@Docker Containers](https://docs.docker.com/engine/reference/commandline/container/)\n- [@official@Docker Exec](https://docs.docker.com/engine/reference/commandline/exec/)\n- [@official@Docker Stop](https://docs.docker.com/engine/reference/commandline/stop/) ",
    "runtime-configuration-options@mAaEz-bwB5DLaBbOSYGMn": "# Runtime Configuration Options\n\nDocker runtime configuration options give you powerful control over your containers' environments. By tweaking resource limits, network settings, security profiles, and logging drivers, you can optimize performance and enhance security. You'll also find options for setting environment variables, mounting volumes, and overriding default behaviors – all crucial for tailoring containers to your specific needs. For more advanced users, there are tools to adjust kernel capabilities and set restart policies. Whether you're using command-line flags or Docker Compose files, these options help ensure your containers run smoothly and consistently, no matter where they're deployed.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Documentation](https://docs.docker.com/engine/reference/run/)\n- [@article@Docker Runtime Arguments](https://galea.medium.com/docker-runtime-arguments-604593479f45)\n",
    "runtime-security@vYug8kcwrMoWf8ft4UDNI": "# Runtime Security\n\nRuntime security in Docker focuses on ensuring the safety and integrity of containers during their execution, safeguarding against vulnerabilities and malicious activities that could arise while the containerized application is running. This involves monitoring container behavior for anomalies, implementing access controls to limit permissions, and employing tools to detect and respond to suspicious activity in real time. Effective runtime security also ensures that only verified images are deployed and continuously audits the system to maintain compliance, thereby providing a robust defense layer to prevent exploits and maintain the desired security posture throughout the container lifecycle.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Security](https://docs.docker.com/engine/security/)\n- [@official@Docker Security Best Practices](https://docs.docker.com/build/building/best-practices/)\n",
    "shell-commands@W5kX5jn49hghRgkEw6_S3": "# Shell Commands",
    "shell-scripting@InlMtuaUJ9EXO-OD9x1jj": "# Shell Scripting",
    "tests@Kmyo1_Mor9WHLkRhNShRZ": "# Tests\n\nWe want to run tests in an environment as similar as possible to production, so it only makes sense to do so inside of our containers! This can include unit tests, integration tests, and end-to-end tests, all run within Docker containers to simulate real-world scenarios while avoiding interference from external dependencies. Using Docker CLI and tools like Docker Compose, you can create isolated testing environments, run tests in parallel, and spin up and tear down the necessary infrastructure automatically.\n\nVisit the following resources to learn more:\n\n- [@article@Running Tests - Docker](https://courses.devopsdirective.com/docker-beginner-to-pro/lessons/11-development-workflow/03-tests)\n- [@feed@Explore top posts about Testing](https://app.daily.dev/tags/testing?ref=roadmapsh)\n",
    "underlying-technologies@jrH1qE6EnFXL4fTyYU8gR": "# Underlying Technologies\n\nDocker containers use Linux kernel technologies for isolation and resource management: namespaces for process isolation, cgroups for resource limits, and union filesystems for efficient layered storage. These enable lightweight, portable, and secure containers that share the host kernel.\n\nVisit the following resources to learn more:\n\n- [@official@Underlying Technologies](https://www.docker.com/resources/what-container/#underlying-technologies)\n- [@article@Underlying Technologies - Medium](https://medium.com/@furkan.turkal/how-does-docker-actually-work-the-hard-way-a-technical-deep-diving-c5b8ea2f0422)\n- [@video@Containers - Namespaces, Cgroups and Overlay Filesystem](https://www.youtube.com/watch?v=wJdDWc6zO4U)\n",
    "union-filesystems@vEUfw_vobshuZI0-q8RZo": "# Union Filesystems\n\nUnion filesystems (UnionFS) create virtual, layered file structures by overlaying multiple directories without modifying originals. Docker uses this to manage storage efficiently by minimizing duplication and reducing image sizes through layered filesystem approach that keeps directory contents separate while mounted together.\n\nVisit the following resources to learn more:\n\n- [@article@AUFS (Advanced Multi-Layered Unification Filesystem)](http://aufs.sourceforge.net/)\n- [@article@OverlayFS (Overlay Filesystem)](https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html)\n- [@article@Btrfs (B-Tree Filesystem)](https://btrfs.readthedocs.io/en/stable/)\n- [@article@ZFS (Z File System)](https://zfsonlinux.org/)\n",
    "users--groups-permissions@uKjB2qntFTpPuYUT9sdxd": "# Users / Groups Permissions",
    "using-3rd-party-container-images@LShK3-1EGGuXnEvdScFR7": "# Using Third Party Images\n\nThird-party images are pre-built Docker container images that are available on Docker Hub or other container registries. These images are created and maintained by individuals or organizations and can be used as a starting point for your containerized applications.\n\n\nVisit the following resources to learn more:\n\n- [@official@Docker Hub Registry](https://hub.docker.com/)\n",
    "volume-mounts@woemCQmWTR-hIoWAci3d5": "# Volume Mounts\n\nVolume mounts are a way to map a folder or file on the host system to a folder or file inside a container. This allows the data to persist outside the container even when the container is removed. Additionally, multiple containers can share the same volume, making data sharing between containers easy.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Volumes](https://docs.docker.com/storage/volumes/).\n- [@official@Docker Volume Flags](https://docs.docker.com/storage/bind-mounts/#choose-the--v-or---mount-flag)\n- [@video@Docker Volumes explained in 6 minutes](https://www.youtube.com/watch?v=p2PH_YPCsis)\n",
    "volumes@eHtVLB6v3h7hatJb-9cZK": "# Docker Volumes\n\nDocker volumes are persistent storage solutions used to manage and store data outside the container's filesystem, ensuring data remains intact even if the container is deleted or recreated. They are ideal for storing application data, logs, and configuration files that need to persist across container restarts and updates. With the Docker CLI, you can create and manage volumes using commands like `docker volume create` to define a new volume, `docker volume ls` to list all volumes, and `docker run -v` to mount a volume to a specific container. This approach helps maintain data integrity, simplifies backup processes, and supports data sharing between containers, making volumes a core part of stateful containerized applications.\n\nVisit the following resources to learn more:\n\n- [@official@Docker Volumes](https://docs.docker.com/storage/volumes/)\n- [@official@Docker Volume Commands](https://docs.docker.com/engine/reference/commandline/volume/)\n",
    "what-are-containers@74JxgfJ_1qmVNZ_QRp9Ne": "# What are Containers?\n\nContainers are lightweight, portable, and isolated software environments that package applications with their dependencies for consistent execution across different platforms. They streamline development, deployment, and management while ensuring applications run reliably regardless of underlying infrastructure.\n\nVisit the following resources to learn more:\n\n- [@official@What is a Container?](https://www.docker.com/resources/what-container/)\n- [@course@Introduction to Containers - AWS Skill Builder](https://explore.skillbuilder.aws/learn/course/106/introduction-to-containers)\n- [@feed@Explore top posts about Containers](https://app.daily.dev/tags/containers?ref=roadmapsh)\n",
    "why-do-we-need-containers@i4ijY3T5gLgNz0XqRipXe": "# Need for Containers\n\nContainers solve environment inconsistency issues when working in teams by standardizing runtime environments. Before containers, significant time was lost configuring local environments to run projects shared by teammates, leading to \"works on my machine\" problems.\n\nVisit the following resources to learn more:\n\n- [@article@Need for Containers](https://www.redhat.com/en/topics/containers)\n"
  },
  "docker": "---\njsonUrl: '/jsons/roadmaps/docker.json'\npdfUrl: '/pdfs/roadmaps/docker.pdf'\norder: 14\nrenderer: 'editor'\nbriefTitle: 'Docker'\nbriefDescription: 'Step by step guide to learning Docker in 2025'\ntitle: 'Docker Roadmap'\ndescription: 'Step by step guide to learning Docker in 2025'\nisNew: false\nhasTopics: true\ndimensions:\n  width: 968\n  height: 1830\nschema:\n  headline: 'Docker Roadmap'\n  description: 'Learn how to use Docker with this interactive step by step guide in 2025. We also have resources and short descriptions attached to the roadmap items so you can get everything you want to learn in one place.'\n  imageUrl: 'https://roadmap.sh/roadmaps/docker.png'\n  datePublished: '2023-05-10'\n  dateModified: '2023-05-10'\nseo:\n  title: 'Docker Roadmap'\n  description: 'Step by step guide to learn Docker in 2025. We also have resources and short descriptions attached to the roadmap items so you can get everything you want to learn in one place.'\n  keywords:\n    - 'docker tutorial'\n    - 'step by step guide for docker'\n    - 'docker for beginners'\n    - 'how to learn docker'\n    - 'use docker in production'\n    - 'docker roadmap 2025'\n    - 'guide to learning docker'\n    - 'docker roadmap'\n    - 'docker learning path'\n    - 'docker learning roadmap'\n    - 'docker learning roadmap 2025'\n    - 'container roadmap'\n    - 'container roadmap 2025'\n    - 'docker'\n    - 'docker learning guide'\n    - 'docker skills'\n    - 'docker for development'\n    - 'docker for development skills'\n    - 'docker for development skills test'\n    - 'docker learning guide'\n    - 'become a docker expert'\n    - 'docker career path'\n    - 'learn docker for development'\n    - 'what is docker'\n    - 'docker quiz'\n    - 'docker interview questions'\nrelatedRoadmaps:\n  - 'devops'\n  - 'backend'\n  - 'kubernetes'\n  - 'linux'\n  - 'aws'\nsitemap:\n  priority: 1\n  changefreq: 'monthly'\ntags:\n  - 'roadmap'\n  - 'main-sitemap'\n  - 'skill-roadmap'\n---\n",
  "migration-mapping": {
    "introduction": "Py9nst2FDJ1_hoXeX_qSF",
    "introduction:what-are-containers": "74JxgfJ_1qmVNZ_QRp9Ne",
    "introduction:need-for-containers": "i4ijY3T5gLgNz0XqRipXe",
    "introduction:bare-metal-vm-containers": "3hatcMVLDbMuz73uTx-9P",
    "introduction:docker-and-oci": "43drPbTwPqJQPyzwYUdBT",
    "underlying-technologies": "jrH1qE6EnFXL4fTyYU8gR",
    "underlying-technologies:namespaces": "BvV8VCX39wRB-g8WvGF1g",
    "underlying-technologies:cgroups": "fRl4EfNwlBiidzn3IV34-",
    "underlying-technologies:union-filesystems": "vEUfw_vobshuZI0-q8RZo",
    "installation-setup": "01nDXqxVdMv4SeXc0nYHH",
    "installation-setup:docker-desktop": "NCdsPRhJy7UtQFNLo1J1f",
    "installation-setup:docker-engine": "0NKqLUWtJMlXn-m6wpA6f",
    "docker-basics": "kIqx7Inf50mE9W0juwNBz",
    "data-persistence": "uUPYXmwu27SBPqKZx6U_q",
    "data-persistence:ephemeral-container-fs": "086zZYjtzdCaDHm-MkSqg",
    "data-persistence:volume-mounts": "woemCQmWTR-hIoWAci3d5",
    "data-persistence:bind-mounts": "wZcCW1ojGzUakHCv2AaI1",
    "using-third-party-images": "LShK3-1EGGuXnEvdScFR7",
    "using-third-party-images:databases": "jKSE_wKYf4P9wnSh_LkMi",
    "using-third-party-images:interactive-test-environments": "HlTxLqKNFMhghtKF6AcWu",
    "using-third-party-images:command-line-utilities": "YzpB7rgSR4ueQRLa0bRWa",
    "building-container-images": "5OEfBQaYNOCi999x6QUqW",
    "building-container-images:dockerfiles": "yGRQcx64S-yBGEoOeMc55",
    "building-container-images:efficient-layer-caching": "frshJqVMP8D7o_7tMZMPI",
    "building-container-images:image-size-and-security": "-8wAzF6_3gruiM3VYMvB0",
    "container-registries": "3VKPiMfbGBxv9m_SljIQV",
    "container-registries:dockerhub": "rxVR62_yXIjc-L4GFSV6u",
    "container-registries:dockerhub-alt": "fh5aERX7c-lY9FPsmftoF",
    "container-registries:image-tagging-best-practices": "Vs4WQwgJFhA63U9Gf2ym0",
    "running-containers": "z2eeBXPzo-diQ67Fcfyhc",
    "running-containers:docker-run": "6eu5NRA1sJuaHTlHtNurc",
    "running-containers:docker-compose": "jjA9E0J8N2frfeJCNtA1m",
    "running-containers:runtime-config-options": "mAaEz-bwB5DLaBbOSYGMn",
    "container-security": "78YFahP3Fg-c27reLkuK4",
    "container-security:image-security": "M5UG-ZcyhBPbksZd0ZdNt",
    "container-security:runtime-security": "vYug8kcwrMoWf8ft4UDNI",
    "docker-cli": "b-LwyYiegbF0jIrn7HYRv",
    "docker-cli:images": "3Nsg-F3wMKEzEsXw1MBZv",
    "docker-cli:containers": "jhwe-xfVc-C7qy8YuS5dZ",
    "docker-cli:volumes": "eHtVLB6v3h7hatJb-9cZK",
    "docker-cli:networks": "w5QjzvOaciK2rotOkjvjQ",
    "developer-experience": "hHXTth0ZP8O-iMGR9xfu9",
    "developer-experience:hot-reloading": "4p5d3rzCHy4vjg2PRX-2k",
    "developer-experience:debuggers": "LiAV9crrTHhLqeZhD25a2",
    "developer-experience:tests": "Kmyo1_Mor9WHLkRhNShRZ",
    "developer-experience:continuous-integration": "oyqw4tr-taZcxt5kREh1g",
    "deploying-containers": "qXOGqORi3EdqwsP9Uhi9m",
    "deploying-containers:paas-options": "PP_RRBo_pThe2mgf6xzMP",
    "deploying-containers:kubernetes": "RqXpX2XabtHYVjgg1EZR_",
    "deploying-containers:docker-swarm": "ks6PFN-0Z9zH7gtWaWgxz",
    "deploying-containers:nomad": "r1eJZDZYouUjnGwAtRbyU"
  }
}